<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Discrete-Time Differential Relaxations · DynamicBounds.jl: Nonlinear Interval Bounds and State Relaxations of Differential Equations</title><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit">DynamicBounds.jl: Nonlinear Interval Bounds and State Relaxations of Differential Equations</span></div><form class="docs-search" action="../search.html"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../index.html">Introduction</a></li><li><a class="tocitem" href="../getting_started.html">Getting Started</a></li><li><a class="tocitem" href="../Base/Base.html">DynamicsBoundsBase, An extendable abstraction layer</a></li><li class="is-active"><a class="tocitem" href="pODEsDiscrete.html">Discrete-Time Differential Relaxations</a><ul class="internal"><li><a class="tocitem" href="#Integrator-used-for-constructing-continuous-time-differential-inequality-bounds/relaxations."><span>Integrator used for constructing continuous time differential inequality bounds/relaxations.</span></a></li><li><a class="tocitem" href="#Contractor-options-for-discretize-and-relaxation-style-calculations"><span>Contractor options for discretize-and-relaxation style calculations</span></a></li></ul></li><li><a class="tocitem" href="../pODEsIneq/pODEsIneq.html">Continuous-Time Differential Relaxations</a></li><li><input class="collapse-toggle" id="menuitem-6" type="checkbox"/><label class="tocitem" for="menuitem-6"><span class="docs-label">Contributing to DynamicBounds</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../Contributing/contributing.html">How to Contribute</a></li><li><a class="tocitem" href="../Contributing/add_problem.html">How to Add a Problem Type</a></li><li><a class="tocitem" href="../Contributing/add_integrator.html">How to Add an Integrator</a></li></ul></li><li><a class="tocitem" href="../ref.html">References</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href="pODEsDiscrete.html">Discrete-Time Differential Relaxations</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href="pODEsDiscrete.html">Discrete-Time Differential Relaxations</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com//blob/master/docs/src/pODEsDiscrete/pODEsDiscrete.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="**DynamicBoundspODEsDiscrete.jl**:-Discrete-time-relaxations/bounds-of-nonlinear-parametric-differential-equations"><a class="docs-heading-anchor" href="#**DynamicBoundspODEsDiscrete.jl**:-Discrete-time-relaxations/bounds-of-nonlinear-parametric-differential-equations"><strong>DynamicBoundspODEsDiscrete.jl</strong>: Discrete-time relaxations/bounds of nonlinear parametric differential equations</a><a id="**DynamicBoundspODEsDiscrete.jl**:-Discrete-time-relaxations/bounds-of-nonlinear-parametric-differential-equations-1"></a><a class="docs-heading-anchor-permalink" href="#**DynamicBoundspODEsDiscrete.jl**:-Discrete-time-relaxations/bounds-of-nonlinear-parametric-differential-equations" title="Permalink"></a></h1><p>This package contains a number of algorithms that computes relaxations via a series of sequential steps. The main integrator exported is the <code>DiscretizeRelax</code> integrator. This computes bounds or relaxations (and (sub)gradients thereof) using a two-step routine: 1) a first step determining a step-size such that the solution of the pODEs is proven to exist over the entire step [tj-1, tj] and 2) a secondary contractor method which refines the bounds/relaxations at time tj. This integrator is initialize in the standard fashion. See the next two sections for keyword arguments and valid state contractors.</p><h2 id="Integrator-used-for-constructing-continuous-time-differential-inequality-bounds/relaxations."><a class="docs-heading-anchor" href="#Integrator-used-for-constructing-continuous-time-differential-inequality-bounds/relaxations.">Integrator used for constructing continuous time differential inequality bounds/relaxations.</a><a id="Integrator-used-for-constructing-continuous-time-differential-inequality-bounds/relaxations.-1"></a><a class="docs-heading-anchor-permalink" href="#Integrator-used-for-constructing-continuous-time-differential-inequality-bounds/relaxations." title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="DynamicBoundspODEsDiscrete.DiscretizeRelax" href="#DynamicBoundspODEsDiscrete.DiscretizeRelax"><code>DynamicBoundspODEsDiscrete.DiscretizeRelax</code></a> — <span class="docstring-category">Type</span></header><section><div><p>DiscretizeRelax</p><p>An integrator for discretize and relaxation techniques.</p><ul><li><p><code>x0f::Any</code></p><p>Initial Condition for pODEs</p></li><li><p><code>Jx!::Any</code></p><p>Jacobian w.r.t x</p></li><li><p><code>Jp!::Any</code></p><p>Jacobian w.r.t p</p></li><li><p><code>p::Vector{Float64}</code></p><p>Parameter value for pODEs</p></li><li><p><code>pL::Vector{Float64}</code></p><p>Lower Parameter Bounds for pODEs</p></li><li><p><code>pU::Vector{Float64}</code></p><p>Upper Parameter Bounds for pODEs</p></li><li><p><code>nx::Int64</code></p><p>Number of state variables</p></li><li><p><code>np::Int64</code></p><p>Number of decision variables</p></li><li><p><code>tspan::Tuple{Float64, Float64}</code></p><p>Time span to integrate over</p></li><li><p><code>tsupports::Vector{Float64}</code></p><p>Individual time points to evaluate</p></li><li><p><code>step_limit::Int64</code></p><p>Maximum number of integration steps</p></li><li><p><code>step_count::Int64</code></p><p>Steps taken</p></li><li><p><code>storage::Array{Vector{T}, 1} where T&lt;:Number</code></p><p>Stores solution X (from step 2) for each time</p></li><li><p><code>storage_apriori::Array{Vector{T}, 1} where T&lt;:Number</code></p><p>Stores solution X (from step 1) for each time</p></li><li><p><code>time::Vector{Float64}</code></p><p>Stores each time t</p></li><li><p><code>support_dict::Dict{Int64, Int64}</code></p><p>Support index to storage dictory</p></li><li><p><code>error_code::TerminationStatusCode</code></p><p>Holds data for numeric error encountered in integration step</p></li><li><p><code>P::Vector{T} where T&lt;:Number</code></p><p>Storage for bounds/relaxation of P</p></li><li><p><code>rP::Vector{T} where T&lt;:Number</code></p><p>Storage for bounds/relaxation of P - p</p></li><li><p><code>style::Number</code></p><p>Relaxation Type</p></li><li><p><code>skip_step2::Bool</code></p><p>Flag indicating that only apriori bounds should be computed</p></li><li><p><code>set_tf!::TaylorFunctor!{F, K, S, T} where {T&lt;:Number, S&lt;:Real, F, K}</code></p><p>Functor for evaluating Taylor coefficients over a set</p></li><li><p><code>method_f!::DynamicBoundspODEsDiscrete.AbstractStateContractor</code></p></li><li><p><code>exist_result::ExistStorage{F, K, S, T} where {T&lt;:Number, S&lt;:Real, F, K}</code></p></li><li><p><code>contractor_result::ContractorStorage{T} where T&lt;:Number</code></p></li><li><p><code>step_result::StepResult{T} where T&lt;:Number</code></p></li><li><p><code>step_params::StepParams</code></p></li><li><p><code>new_decision_pnt::Bool</code></p></li><li><p><code>new_decision_box::Bool</code></p></li><li><p><code>relax_t_dict_indx::Dict{Int64, Int64}</code></p></li><li><p><code>relax_t_dict_flt::Dict{Float64, Int64}</code></p></li><li><p><code>calculate_local_sensitivity::Bool</code></p></li><li><p><code>local_problem_storage::Any</code></p></li><li><p><code>constant_state_bounds::Union{Nothing, ConstantStateBounds}</code></p></li><li><p><code>polyhedral_constraint::Union{Nothing, PolyhedralConstraint}</code></p></li><li><p><code>prob::Any</code></p></li></ul></div></section></article><h2 id="Contractor-options-for-discretize-and-relaxation-style-calculations"><a class="docs-heading-anchor" href="#Contractor-options-for-discretize-and-relaxation-style-calculations">Contractor options for discretize-and-relaxation style calculations</a><a id="Contractor-options-for-discretize-and-relaxation-style-calculations-1"></a><a class="docs-heading-anchor-permalink" href="#Contractor-options-for-discretize-and-relaxation-style-calculations" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="DynamicBoundspODEsDiscrete.AbstractStateContractorName" href="#DynamicBoundspODEsDiscrete.AbstractStateContractorName"><code>DynamicBoundspODEsDiscrete.AbstractStateContractorName</code></a> — <span class="docstring-category">Type</span></header><section><div><p>AbstractStateContractorName</p><p>The subtypes of <code>AbstractStateContractorName</code> are used to specify the manner of contractor method to be used by <code>DiscretizeRelax</code> in the discretize and relax scheme.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="DynamicBoundspODEsDiscrete.LohnerContractor" href="#DynamicBoundspODEsDiscrete.LohnerContractor"><code>DynamicBoundspODEsDiscrete.LohnerContractor</code></a> — <span class="docstring-category">Type</span></header><section><div><p>LohnerContractor{K}</p><p>An <code>AbstractStateContractorName</code> used to specify a parametric Lohners method contractor of order K.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="DynamicBoundspODEsDiscrete.HermiteObreschkoff" href="#DynamicBoundspODEsDiscrete.HermiteObreschkoff"><code>DynamicBoundspODEsDiscrete.HermiteObreschkoff</code></a> — <span class="docstring-category">Type</span></header><section><div><p>HermiteObreschkoff</p><p>A structure that stores the cofficient of the (P,Q)-Hermite-Obreschkoff method. (Offset due to method being zero indexed and Julia begin one indexed). The constructor <code>HermiteObreschkoff(p::Val{P}, q::Val{Q}) where {P, Q}</code> or <code>HermiteObreschkoff(p::Int, q::Int)</code> are used for the (P,Q)-method.</p><ul><li><p><code>cpq::Vector{Float64}</code></p><p>Cpq[i=1:p] index starting at i = 1 rather than 0</p></li><li><p><code>cqp::Vector{Float64}</code></p><p>Cqp[i=1:q] index starting at i = 1 rather than 0</p></li><li><p><code>γ::Float64</code></p><p>gamma for method</p></li><li><p><code>p::Int64</code></p><p>Explicit order Hermite-Obreschkoff</p></li><li><p><code>q::Int64</code></p><p>Implicit order Hermite-Obreschkoff</p></li><li><p><code>k::Int64</code></p><p>Total order Hermite-Obreschkoff</p></li></ul></div></section></article><h3 id="Computation-of-Taylor-Functions-and-Jacobians"><a class="docs-heading-anchor" href="#Computation-of-Taylor-Functions-and-Jacobians">Computation of Taylor Functions and Jacobians</a><a id="Computation-of-Taylor-Functions-and-Jacobians-1"></a><a class="docs-heading-anchor-permalink" href="#Computation-of-Taylor-Functions-and-Jacobians" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="DynamicBoundspODEsDiscrete.jetcoeffs!" href="#DynamicBoundspODEsDiscrete.jetcoeffs!"><code>DynamicBoundspODEsDiscrete.jetcoeffs!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">jetcoeffs!(eqsdiff!, t::T&lt;:Number, x::Array{DynamicBoundspODEsDiscrete.StaticTaylorSeries.STaylor1{N, U&lt;:Number}, 1}, xaux::Array{DynamicBoundspODEsDiscrete.StaticTaylorSeries.STaylor1{N, U&lt;:Number}, 1}, dx::Array{DynamicBoundspODEsDiscrete.StaticTaylorSeries.STaylor1{N, U&lt;:Number}, 1}, order::Int64, params, vnxt::Vector{Int64}, fnxt::Vector{Float64})
</code></pre><p>A variant of the jetcoeffs! function used in TaylorIntegration.jl (https://github.com/PerezHz/TaylorIntegration.jl/blob/master/src/explicitode.jl) which preallocates taux and updates taux coefficients to avoid further allocations.</p><p>The TaylorIntegration.jl package is licensed under the MIT &quot;Expat&quot; License: Copyright (c) 2016-2020: Jorge A. Perez and Luis Benet. Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the &quot;Software&quot;), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="DynamicBoundspODEsDiscrete.TaylorFunctor!" href="#DynamicBoundspODEsDiscrete.TaylorFunctor!"><code>DynamicBoundspODEsDiscrete.TaylorFunctor!</code></a> — <span class="docstring-category">Type</span></header><section><div><p>TaylorFunctor!</p><p>A function g!(out, y) that perfoms a Taylor coefficient calculation. Provides preallocated storage. Evaluating this function out is a vector of length nx<em>(s+1) where 1:(s+1) are the Taylor coefficients of the first component, (s+2):nx</em>(s+1) are the Taylor coefficients of the second component, and so on. This may be constructed using <code>TaylorFunctor!(g!, nx::Int, np::Int, k::Val{K}, t::T, q::Q)</code> were type <code>T</code> should use type <code>Q</code> for internal computations. The order of the TaylorSeries is <code>k</code>, the right-hand side function is <code>g!</code>, <code>nx</code> is the number of state variables, <code>np</code> is the number of parameters.</p><ul><li><p><code>g!::Function</code></p><p>Right-hand side function for pODE which operates in place as g!(dx,x,p,t)</p></li><li><p><code>nx::Int64</code></p><p>Dimensionality of x</p></li><li><p><code>np::Int64</code></p><p>Dimensionality of p</p></li><li><p><code>k::Int64</code></p><p>Order of TaylorSeries, that is the first k terms are used in the approximation     and N = k+1 term is bounded</p></li><li><p><code>x::Vector{S} where S&lt;:Real</code></p><p>State variables x</p></li><li><p><code>p::Vector{S} where S&lt;:Real</code></p><p>Decision variables p</p></li><li><p><code>xtaylor::Array{DynamicBoundspODEsDiscrete.StaticTaylorSeries.STaylor1{N, S}, 1} where {N, S&lt;:Real}</code></p><p>Store temporary STaylor1 vector for calculations</p></li><li><p><code>xaux::Array{DynamicBoundspODEsDiscrete.StaticTaylorSeries.STaylor1{N, S}, 1} where {N, S&lt;:Real}</code></p><p>Store temporary STaylor1 vector for calculations</p></li><li><p><code>dx::Array{DynamicBoundspODEsDiscrete.StaticTaylorSeries.STaylor1{N, S}, 1} where {N, S&lt;:Real}</code></p><p>Store temporary STaylor1 vector for calculations</p></li><li><p><code>taux::Array{DynamicBoundspODEsDiscrete.StaticTaylorSeries.STaylor1{N, T}, 1} where {N, T&lt;:Real}</code></p></li><li><p><code>vnxt::Vector{Int64}</code></p></li><li><p><code>fnxt::Vector{Float64}</code></p></li></ul></div></section></article><article class="docstring"><header><a class="docstring-binding" id="DynamicBoundspODEsDiscrete.JacTaylorFunctor!" href="#DynamicBoundspODEsDiscrete.JacTaylorFunctor!"><code>DynamicBoundspODEsDiscrete.JacTaylorFunctor!</code></a> — <span class="docstring-category">Type</span></header><section><div><p>JacTaylorFunctor!</p><p>A callable structure used to evaluate the Jacobian of Taylor cofficients. This also contains some addition fields to be used as inplace storage when computing and preconditioning paralleliped based methods to representing enclosure of the pODEs (Lohner&#39;s QR, Hermite-Obreschkoff, etc.). The constructor given by <code>JacTaylorFunctor!(g!, nx::Int, np::Int, k::Val{K}, t::T, q::Q)</code> may be used were type <code>T</code> should use type <code>Q</code> for internal computations. The order of the TaylorSeries is <code>k</code>, the right-hand side function is <code>g!</code>, <code>nx</code> is the number of state variables, <code>np</code> is the number of parameters.</p><ul><li><p><code>g!::Function</code></p><p>Right-hand side function for pODE which operates in place as g!(dx,x,p,t)</p></li><li><p><code>nx::Int64</code></p><p>Dimensionality of x</p></li><li><p><code>np::Int64</code></p><p>Dimensionality of p</p></li><li><p><code>s::Int64</code></p><p>Order of TaylorSeries</p></li><li><p><code>out::Vector{S} where S&lt;:Real</code></p><p>In-place temporary storage for Taylor coefficient calculation</p></li><li><p><code>y::Vector{S} where S&lt;:Real</code></p><p>Variables y = (x,p)</p></li><li><p><code>x::Array{ForwardDiff.Dual{Nothing, S, NY}, 1} where {S&lt;:Real, NY}</code></p><p>State variables x</p></li><li><p><code>p::Array{ForwardDiff.Dual{Nothing, S, NY}, 1} where {S&lt;:Real, NY}</code></p><p>Decision variables p</p></li><li><p><code>Jxsto::Matrix{S} where S&lt;:Real</code></p><p>Storage for sum of Jacobian w.r.t x</p></li><li><p><code>Jpsto::Matrix{S} where S&lt;:Real</code></p><p>Storage for sum of Jacobian w.r.t p</p></li><li><p><code>tjac::Matrix{S} where S&lt;:Real</code></p><p>Temporary for transpose of Jacobian w.r.t y</p></li><li><p><code>Jx::Array{Matrix{S}, 1} where S&lt;:Real</code></p><p>Storage for vector of Jacobian w.r.t x</p></li><li><p><code>Jp::Array{Matrix{S}, 1} where S&lt;:Real</code></p><p>Storage for vector of Jacobian w.r.t p</p></li><li><p><code>result::DiffResults.MutableDiffResult{1, Vector{S}, Tuple{Matrix{S}}} where S&lt;:Real</code></p><p>Jacobian Result from DiffResults</p></li><li><p><code>cfg::ForwardDiff.JacobianConfig{Nothing, S, NY, Tuple{Array{ForwardDiff.Dual{Nothing, S, NY}, 1}, Array{ForwardDiff.Dual{Nothing, S, NY}, 1}}} where {S&lt;:Real, NY}</code></p><p>Jacobian Configuration for ForwardDiff</p></li><li><p><code>xtaylor::Array{DynamicBoundspODEsDiscrete.StaticTaylorSeries.STaylor1{N, ForwardDiff.Dual{Nothing, S, NY}}, 1} where {N, S&lt;:Real, NY}</code></p><p>Store temporary STaylor1 vector for calculations</p></li><li><p><code>xaux::Array{DynamicBoundspODEsDiscrete.StaticTaylorSeries.STaylor1{N, ForwardDiff.Dual{Nothing, S, NY}}, 1} where {N, S&lt;:Real, NY}</code></p><p>Store temporary STaylor1 vector for calculations</p></li><li><p><code>dx::Array{DynamicBoundspODEsDiscrete.StaticTaylorSeries.STaylor1{N, ForwardDiff.Dual{Nothing, S, NY}}, 1} where {N, S&lt;:Real, NY}</code></p><p>Store temporary STaylor1 vector for calculations</p></li><li><p><code>taux::Array{DynamicBoundspODEsDiscrete.StaticTaylorSeries.STaylor1{N, T}, 1} where {N, T&lt;:Real}</code></p></li><li><p><code>t::Float64</code></p></li><li><p><code>vnxt::Vector{Int64}</code></p><p>Intermediate storage to avoid allocations in Taylor coefficient calc</p></li><li><p><code>fnxt::Vector{Float64}</code></p><p>Intermediate storage to avoid allocations in Taylor coefficient calc</p></li></ul></div></section></article><article class="docstring"><header><a class="docstring-binding" id="DynamicBoundspODEsDiscrete.jacobian_taylor_coeffs!" href="#DynamicBoundspODEsDiscrete.jacobian_taylor_coeffs!"><code>DynamicBoundspODEsDiscrete.jacobian_taylor_coeffs!</code></a> — <span class="docstring-category">Function</span></header><section><div><p>jacobian<em>taylor</em>coeffs!</p><p>Computes the Jacobian of the Taylor coefficients w.r.t. y = (x,p) storing the output inplace to <code>result</code>. A JacobianConfig object without tag checking, cfg, is required input and is initialized from <code>cfg = ForwardDiff.JacobianConfig(nothing, out, y)</code>. The JacTaylorFunctor! used for the evaluation is <code>g</code> and inputs are <code>x</code> and <code>p</code>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="DynamicBoundspODEsDiscrete.set_JxJp!" href="#DynamicBoundspODEsDiscrete.set_JxJp!"><code>DynamicBoundspODEsDiscrete.set_JxJp!</code></a> — <span class="docstring-category">Function</span></header><section><div><p>set_JxJp!</p><p>Extracts the Jacobian of the Taylor coefficients w.r.t. x, <code>Jx</code>, and the Jacobian of the Taylor coefficients w.r.t. p, <code>Jp</code>, from <code>result</code>. The order of the Taylor series is <code>s</code>, the dimensionality of x is <code>nx</code>, the dimensionality of p is <code>np</code>, and <code>tjac</code> is preallocated storage for the transpose of the Jacobian w.r.t. y = (x,p).</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="DynamicBoundspODEsDiscrete.LohnersFunctor" href="#DynamicBoundspODEsDiscrete.LohnersFunctor"><code>DynamicBoundspODEsDiscrete.LohnersFunctor</code></a> — <span class="docstring-category">Type</span></header><section><div><p>LohnersFunctor</p><p>A functor used in computing bounds and relaxations via Lohner&#39;s method. The implementation of the parametric Lohner&#39;s method described in the paper in (1) based on the non-parametric version given in (2).</p><ol><li>[Sahlodin, Ali M., and Benoit Chachuat. &quot;Discretize-then-relax approach for</li></ol><p>convex/concave relaxations of the solutions of parametric ODEs.&quot; Applied Numerical Mathematics 61.7 (2011): 803-820.](https://www.sciencedirect.com/science/article/abs/pii/S0168927411000316)</p><ol><li>[R.J. Lohner, Computation of guaranteed enclosures for the solutions of</li></ol><p>ordinary initial and boundary value problems, in: J.R. Cash, I. Gladwell (Eds.), Computational Ordinary Differential Equations, vol. 1, Clarendon Press, 1992, pp. 425–436.](http://www.goldsztejn.com/old-papers/Lohner-1992.pdf)</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="DynamicBoundspODEsDiscrete.HermiteObreschkoffFunctor" href="#DynamicBoundspODEsDiscrete.HermiteObreschkoffFunctor"><code>DynamicBoundspODEsDiscrete.HermiteObreschkoffFunctor</code></a> — <span class="docstring-category">Type</span></header><section><div><p>HermiteObreschkoffFunctor</p><p>A functor used in computing bounds and relaxations via Hermite-Obreschkoff&#39;s method. The implementation of the parametric Hermite-Obreschkoff&#39;s method based on the non-parametric version given in (1).</p><ol><li>[Nedialkov NS, and Jackson KR. &quot;An interval Hermite-Obreschkoff method for</li></ol><p>computing rigorous bounds on the solution of an initial value problem for an ordinary differential equation.&quot; Reliable Computing 5.3 (1999): 289-310.](https://link.springer.com/article/10.1023/A:1009936607335)</p><ol><li>[Nedialkov NS. &quot;Computing rigorous bounds on the solution of an</li></ol><p>initial value problem for an ordinary differential equation.&quot; University of Toronto. 2000.](http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.633.9654&amp;rep=rep1&amp;type=pdf)</p></div></section></article><h3 id="Existence-and-Uniqueness-Test-Utility-Functions"><a class="docs-heading-anchor" href="#Existence-and-Uniqueness-Test-Utility-Functions">Existence and Uniqueness Test Utility Functions</a><a id="Existence-and-Uniqueness-Test-Utility-Functions-1"></a><a class="docs-heading-anchor-permalink" href="#Existence-and-Uniqueness-Test-Utility-Functions" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="DynamicBoundspODEsDiscrete.improvement_condition" href="#DynamicBoundspODEsDiscrete.improvement_condition"><code>DynamicBoundspODEsDiscrete.improvement_condition</code></a> — <span class="docstring-category">Function</span></header><section><div><p>improvement_condition</p><p>Fast check for to see if the ratio of the L∞ norm is improving in a given iteration using a hard-code ratio tolerance of 1.01. This is the improvement condition from Nedialko S. Nedialkov. Computing rigorous bounds on the solution of an initial value problem for an ordinary differential equation. 1999. Universisty of Toronto, PhD Dissertation, Algorithm 5.1, page 73-74).</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="DynamicBoundspODEsDiscrete.contains" href="#DynamicBoundspODEsDiscrete.contains"><code>DynamicBoundspODEsDiscrete.contains</code></a> — <span class="docstring-category">Function</span></header><section><div><p>contains</p><p>Checks that an interval vector <code>Vⱼ</code> of length <code>nx</code> is contained in <code>Uⱼ</code>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="DynamicBoundspODEsDiscrete.excess_error" href="#DynamicBoundspODEsDiscrete.excess_error"><code>DynamicBoundspODEsDiscrete.excess_error</code></a> — <span class="docstring-category">Function</span></header><section><div><p>excess_error</p><p>Computes the excess error using a norm-∞ of the diameter of the vectors.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="DynamicBoundspODEsDiscrete.calc_alpha" href="#DynamicBoundspODEsDiscrete.calc_alpha"><code>DynamicBoundspODEsDiscrete.calc_alpha</code></a> — <span class="docstring-category">Function</span></header><section><div><p>calc_alpha</p><p>Computes the stepsize for the adaptive step-routine.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="DynamicBoundspODEsDiscrete.ExistStorage" href="#DynamicBoundspODEsDiscrete.ExistStorage"><code>DynamicBoundspODEsDiscrete.ExistStorage</code></a> — <span class="docstring-category">Type</span></header><section><div><p>ExistStorage{F,K,S,T}</p><p>Storage used in the existence and uniqueness tests.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="DynamicBoundspODEsDiscrete.state_contractor_k" href="#DynamicBoundspODEsDiscrete.state_contractor_k"><code>DynamicBoundspODEsDiscrete.state_contractor_k</code></a> — <span class="docstring-category">Function</span></header><section><div><p>state<em>contractor</em>k(d::AbstractStateContractorName)</p><p>Retrieves the order of the existence test to be used with</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="DynamicBoundspODEsDiscrete.state_contractor_γ" href="#DynamicBoundspODEsDiscrete.state_contractor_γ"><code>DynamicBoundspODEsDiscrete.state_contractor_γ</code></a> — <span class="docstring-category">Function</span></header><section><div><p>state<em>contractor</em>γ(d::AbstractStateContractorName)</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="DynamicBoundspODEsDiscrete.state_contractor_steps" href="#DynamicBoundspODEsDiscrete.state_contractor_steps"><code>DynamicBoundspODEsDiscrete.state_contractor_steps</code></a> — <span class="docstring-category">Function</span></header><section><div><p>state<em>contractor</em>steps(d::AbstractStateContractorName)</p></div></section></article><h3 id="Utilities-for-overall-discretize-and-relaxation-scheme"><a class="docs-heading-anchor" href="#Utilities-for-overall-discretize-and-relaxation-scheme">Utilities for overall discretize-and-relaxation scheme</a><a id="Utilities-for-overall-discretize-and-relaxation-scheme-1"></a><a class="docs-heading-anchor-permalink" href="#Utilities-for-overall-discretize-and-relaxation-scheme" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="DynamicBoundspODEsDiscrete.StepParams" href="#DynamicBoundspODEsDiscrete.StepParams"><code>DynamicBoundspODEsDiscrete.StepParams</code></a> — <span class="docstring-category">Type</span></header><section><div><p>StepParams</p><p>LEPUS and Integration parameters.</p><ul><li><p><code>tol::Float64</code></p><p>Error tolerance of integrator</p></li><li><p><code>hmin::Float64</code></p><p>Minimum stepsize</p></li><li><p><code>repeat_limit::Int64</code></p><p>Number of repetitions allowed for refinement</p></li><li><p><code>is_adaptive::Bool</code></p><p>Indicates an adaptive stepsize is used</p></li><li><p><code>skip_step2::Bool</code></p><p>Indicates the contractor step should be skipped</p></li></ul></div></section></article><article class="docstring"><header><a class="docstring-binding" id="DynamicBoundspODEsDiscrete.StepResult" href="#DynamicBoundspODEsDiscrete.StepResult"><code>DynamicBoundspODEsDiscrete.StepResult</code></a> — <span class="docstring-category">Type</span></header><section><div><p>StepResult{S}</p><p>Results passed to the next step.</p><ul><li><p><code>xⱼ::Vector{Float64}</code></p><p>nominal value of the state variables</p></li><li><p><code>Xⱼ::Vector{S} where S</code></p><p>relaxations/bounds of the state variables</p></li><li><p><code>A_Q::DynamicBoundspODEsDiscrete.FixedCircularBuffer{Matrix{Float64}}</code></p><p>storage for parallelepid enclosure of <code>xⱼ</code></p></li><li><p><code>A_inv::DynamicBoundspODEsDiscrete.FixedCircularBuffer{Matrix{Float64}}</code></p></li><li><p><code>Δ::DynamicBoundspODEsDiscrete.FixedCircularBuffer{Vector{S}} where S</code></p><p>storage for parallelepid enclosure of <code>xⱼ</code></p></li><li><p><code>predicted_hj::Float64</code></p><p>predicted step size for next step</p></li><li><p><code>time::Float64</code></p><p>new time</p></li></ul></div></section></article><article class="docstring"><header><a class="docstring-binding" id="DynamicBoundspODEsDiscrete.ContractorStorage" href="#DynamicBoundspODEsDiscrete.ContractorStorage"><code>DynamicBoundspODEsDiscrete.ContractorStorage</code></a> — <span class="docstring-category">Type</span></header><section><div><p>ContractorStorage{S}</p><p>Storage used to hold inputs to the contractor method used.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="DynamicBoundspODEsDiscrete.single_step!" href="#DynamicBoundspODEsDiscrete.single_step!"><code>DynamicBoundspODEsDiscrete.single_step!</code></a> — <span class="docstring-category">Function</span></header><section><div><p>single_step!</p><p>Performs a single-step of the validated integrator. Input stepsize is out.step.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="DynamicBoundspODEsDiscrete.set_P!-Tuple{DiscretizeRelax}" href="#DynamicBoundspODEsDiscrete.set_P!-Tuple{DiscretizeRelax}"><code>DynamicBoundspODEsDiscrete.set_P!</code></a> — <span class="docstring-category">Method</span></header><section><div><p>set_P!(d::DiscretizeRelax)</p><p>Initializes the <code>P</code> and <code>rP</code> (P - p) fields of <code>d</code>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="DynamicBoundspODEsDiscrete.compute_X0!-Tuple{DiscretizeRelax}" href="#DynamicBoundspODEsDiscrete.compute_X0!-Tuple{DiscretizeRelax}"><code>DynamicBoundspODEsDiscrete.compute_X0!</code></a> — <span class="docstring-category">Method</span></header><section><div><p>compute_X0!(d::DiscretizeRelax)</p><p>Initializes the circular buffer that holds <code>Δ</code> with the <code>out - mid(out)</code> at index 1 and a zero vector at all other indices.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="DynamicBoundspODEsDiscrete.set_Δ!" href="#DynamicBoundspODEsDiscrete.set_Δ!"><code>DynamicBoundspODEsDiscrete.set_Δ!</code></a> — <span class="docstring-category">Function</span></header><section><div><p>set_Δ!</p><p>Initializes the circular buffer, <code>Δ</code>, that holds <code>Δ_i</code> with the <code>out - mid(out)</code> at index 1 and a zero vector at all other indices.</p></div></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../Base/Base.html">« DynamicsBoundsBase, An extendable abstraction layer</a><a class="docs-footer-nextpage" href="../pODEsIneq/pODEsIneq.html">Continuous-Time Differential Relaxations »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Thursday 22 July 2021 16:42">Thursday 22 July 2021</span>. Using Julia version 1.6.0.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
