var documenterSearchIndex = {"docs":
[{"location":"pODEsDiscrete/pODEsDiscrete.html#**DynamicBoundspODEsDiscrete.jl**:-Discrete-time-relaxations/bounds-of-nonlinear-parametric-differential-equations","page":"Discrete-Time Differential Relaxations","title":"DynamicBoundspODEsDiscrete.jl: Discrete-time relaxations/bounds of nonlinear parametric differential equations","text":"","category":"section"},{"location":"pODEsDiscrete/pODEsDiscrete.html","page":"Discrete-Time Differential Relaxations","title":"Discrete-Time Differential Relaxations","text":"This package contains a number of algorithms that computes relaxations via a series of sequential steps. The main integrator exported is the DiscretizeRelax integrator. This computes bounds or relaxations (and (sub)gradients thereof) using a two-step routine: 1) a first step determining a step-size such that the solution of the pODEs is proven to exist over the entire step [tj-1, tj] and 2) a secondary contractor method which refines the bounds/relaxations at time tj. This integrator is initialize in the standard fashion. See the next two sections for keyword arguments and valid state contractors.","category":"page"},{"location":"pODEsDiscrete/pODEsDiscrete.html#Integrator-used-for-constructing-continuous-time-differential-inequality-bounds/relaxations.","page":"Discrete-Time Differential Relaxations","title":"Integrator used for constructing continuous time differential inequality bounds/relaxations.","text":"","category":"section"},{"location":"pODEsDiscrete/pODEsDiscrete.html","page":"Discrete-Time Differential Relaxations","title":"Discrete-Time Differential Relaxations","text":"DiscretizeRelax","category":"page"},{"location":"pODEsDiscrete/pODEsDiscrete.html#DynamicBoundspODEsDiscrete.DiscretizeRelax","page":"Discrete-Time Differential Relaxations","title":"DynamicBoundspODEsDiscrete.DiscretizeRelax","text":"DiscretizeRelax\n\nAn integrator for discretize and relaxation techniques.\n\nx0f::Any\nInitial Condition for pODEs\nJx!::Any\nJacobian w.r.t x\nJp!::Any\nJacobian w.r.t p\np::Vector{Float64}\nParameter value for pODEs\npL::Vector{Float64}\nLower Parameter Bounds for pODEs\npU::Vector{Float64}\nUpper Parameter Bounds for pODEs\nnx::Int64\nNumber of state variables\nnp::Int64\nNumber of decision variables\ntspan::Tuple{Float64, Float64}\nTime span to integrate over\ntsupports::Vector{Float64}\nIndividual time points to evaluate\nstep_limit::Int64\nMaximum number of integration steps\nstep_count::Int64\nSteps taken\nstorage::Array{Vector{T}, 1} where T<:Number\nStores solution X (from step 2) for each time\nstorage_apriori::Array{Vector{T}, 1} where T<:Number\nStores solution X (from step 1) for each time\ntime::Vector{Float64}\nStores each time t\nsupport_dict::Dict{Int64, Int64}\nSupport index to storage dictory\nerror_code::TerminationStatusCode\nHolds data for numeric error encountered in integration step\nP::Vector{T} where T<:Number\nStorage for bounds/relaxation of P\nrP::Vector{T} where T<:Number\nStorage for bounds/relaxation of P - p\nstyle::Number\nRelaxation Type\nskip_step2::Bool\nFlag indicating that only apriori bounds should be computed\nset_tf!::TaylorFunctor!{F, K, S, T} where {T<:Number, S<:Real, F, K}\nFunctor for evaluating Taylor coefficients over a set\nmethod_f!::DynamicBoundspODEsDiscrete.AbstractStateContractor\nexist_result::ExistStorage{F, K, S, T} where {T<:Number, S<:Real, F, K}\ncontractor_result::ContractorStorage{T} where T<:Number\nstep_result::StepResult{T} where T<:Number\nstep_params::StepParams\nnew_decision_pnt::Bool\nnew_decision_box::Bool\nrelax_t_dict_indx::Dict{Int64, Int64}\nrelax_t_dict_flt::Dict{Float64, Int64}\ncalculate_local_sensitivity::Bool\nlocal_problem_storage::Any\nconstant_state_bounds::Union{Nothing, ConstantStateBounds}\npolyhedral_constraint::Union{Nothing, PolyhedralConstraint}\nprob::Any\n\n\n\n\n\n","category":"type"},{"location":"pODEsDiscrete/pODEsDiscrete.html#Contractor-options-for-discretize-and-relaxation-style-calculations","page":"Discrete-Time Differential Relaxations","title":"Contractor options for discretize-and-relaxation style calculations","text":"","category":"section"},{"location":"pODEsDiscrete/pODEsDiscrete.html","page":"Discrete-Time Differential Relaxations","title":"Discrete-Time Differential Relaxations","text":"AbstractStateContractorName\r\nLohnerContractor{K}\r\nHermiteObreschkoff","category":"page"},{"location":"pODEsDiscrete/pODEsDiscrete.html#DynamicBoundspODEsDiscrete.AbstractStateContractorName","page":"Discrete-Time Differential Relaxations","title":"DynamicBoundspODEsDiscrete.AbstractStateContractorName","text":"AbstractStateContractorName\n\nThe subtypes of AbstractStateContractorName are used to specify the manner of contractor method to be used by DiscretizeRelax in the discretize and relax scheme.\n\n\n\n\n\n","category":"type"},{"location":"pODEsDiscrete/pODEsDiscrete.html#DynamicBoundspODEsDiscrete.LohnerContractor","page":"Discrete-Time Differential Relaxations","title":"DynamicBoundspODEsDiscrete.LohnerContractor","text":"LohnerContractor{K}\n\nAn AbstractStateContractorName used to specify a parametric Lohners method contractor of order K.\n\n\n\n\n\n","category":"type"},{"location":"pODEsDiscrete/pODEsDiscrete.html#DynamicBoundspODEsDiscrete.HermiteObreschkoff","page":"Discrete-Time Differential Relaxations","title":"DynamicBoundspODEsDiscrete.HermiteObreschkoff","text":"HermiteObreschkoff\n\nA structure that stores the cofficient of the (P,Q)-Hermite-Obreschkoff method. (Offset due to method being zero indexed and Julia begin one indexed). The constructor HermiteObreschkoff(p::Val{P}, q::Val{Q}) where {P, Q} or HermiteObreschkoff(p::Int, q::Int) are used for the (P,Q)-method.\n\ncpq::Vector{Float64}\nCpq[i=1:p] index starting at i = 1 rather than 0\ncqp::Vector{Float64}\nCqp[i=1:q] index starting at i = 1 rather than 0\nγ::Float64\ngamma for method\np::Int64\nExplicit order Hermite-Obreschkoff\nq::Int64\nImplicit order Hermite-Obreschkoff\nk::Int64\nTotal order Hermite-Obreschkoff\n\n\n\n\n\n","category":"type"},{"location":"pODEsDiscrete/pODEsDiscrete.html#Computation-of-Taylor-Functions-and-Jacobians","page":"Discrete-Time Differential Relaxations","title":"Computation of Taylor Functions and Jacobians","text":"","category":"section"},{"location":"pODEsDiscrete/pODEsDiscrete.html","page":"Discrete-Time Differential Relaxations","title":"Discrete-Time Differential Relaxations","text":"jetcoeffs!\r\nTaylorFunctor!\r\nJacTaylorFunctor!\r\njacobian_taylor_coeffs!\r\nset_JxJp!\r\nLohnersFunctor\r\nHermiteObreschkoffFunctor","category":"page"},{"location":"pODEsDiscrete/pODEsDiscrete.html#DynamicBoundspODEsDiscrete.jetcoeffs!","page":"Discrete-Time Differential Relaxations","title":"DynamicBoundspODEsDiscrete.jetcoeffs!","text":"jetcoeffs!(eqsdiff!, t::T<:Number, x::Array{DynamicBoundspODEsDiscrete.StaticTaylorSeries.STaylor1{N, U<:Number}, 1}, xaux::Array{DynamicBoundspODEsDiscrete.StaticTaylorSeries.STaylor1{N, U<:Number}, 1}, dx::Array{DynamicBoundspODEsDiscrete.StaticTaylorSeries.STaylor1{N, U<:Number}, 1}, order::Int64, params, vnxt::Vector{Int64}, fnxt::Vector{Float64})\n\n\nA variant of the jetcoeffs! function used in TaylorIntegration.jl (https://github.com/PerezHz/TaylorIntegration.jl/blob/master/src/explicitode.jl) which preallocates taux and updates taux coefficients to avoid further allocations.\n\nThe TaylorIntegration.jl package is licensed under the MIT \"Expat\" License: Copyright (c) 2016-2020: Jorge A. Perez and Luis Benet. Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.\n\n\n\n\n\n","category":"function"},{"location":"pODEsDiscrete/pODEsDiscrete.html#DynamicBoundspODEsDiscrete.TaylorFunctor!","page":"Discrete-Time Differential Relaxations","title":"DynamicBoundspODEsDiscrete.TaylorFunctor!","text":"TaylorFunctor!\n\nA function g!(out, y) that perfoms a Taylor coefficient calculation. Provides preallocated storage. Evaluating this function out is a vector of length nx(s+1) where 1:(s+1) are the Taylor coefficients of the first component, (s+2):nx(s+1) are the Taylor coefficients of the second component, and so on. This may be constructed using TaylorFunctor!(g!, nx::Int, np::Int, k::Val{K}, t::T, q::Q) were type T should use type Q for internal computations. The order of the TaylorSeries is k, the right-hand side function is g!, nx is the number of state variables, np is the number of parameters.\n\ng!::Function\nRight-hand side function for pODE which operates in place as g!(dx,x,p,t)\nnx::Int64\nDimensionality of x\nnp::Int64\nDimensionality of p\nk::Int64\nOrder of TaylorSeries, that is the first k terms are used in the approximation     and N = k+1 term is bounded\nx::Vector{S} where S<:Real\nState variables x\np::Vector{S} where S<:Real\nDecision variables p\nxtaylor::Array{DynamicBoundspODEsDiscrete.StaticTaylorSeries.STaylor1{N, S}, 1} where {N, S<:Real}\nStore temporary STaylor1 vector for calculations\nxaux::Array{DynamicBoundspODEsDiscrete.StaticTaylorSeries.STaylor1{N, S}, 1} where {N, S<:Real}\nStore temporary STaylor1 vector for calculations\ndx::Array{DynamicBoundspODEsDiscrete.StaticTaylorSeries.STaylor1{N, S}, 1} where {N, S<:Real}\nStore temporary STaylor1 vector for calculations\ntaux::Array{DynamicBoundspODEsDiscrete.StaticTaylorSeries.STaylor1{N, T}, 1} where {N, T<:Real}\nvnxt::Vector{Int64}\nfnxt::Vector{Float64}\n\n\n\n\n\n","category":"type"},{"location":"pODEsDiscrete/pODEsDiscrete.html#DynamicBoundspODEsDiscrete.JacTaylorFunctor!","page":"Discrete-Time Differential Relaxations","title":"DynamicBoundspODEsDiscrete.JacTaylorFunctor!","text":"JacTaylorFunctor!\n\nA callable structure used to evaluate the Jacobian of Taylor cofficients. This also contains some addition fields to be used as inplace storage when computing and preconditioning paralleliped based methods to representing enclosure of the pODEs (Lohner's QR, Hermite-Obreschkoff, etc.). The constructor given by JacTaylorFunctor!(g!, nx::Int, np::Int, k::Val{K}, t::T, q::Q) may be used were type T should use type Q for internal computations. The order of the TaylorSeries is k, the right-hand side function is g!, nx is the number of state variables, np is the number of parameters.\n\ng!::Function\nRight-hand side function for pODE which operates in place as g!(dx,x,p,t)\nnx::Int64\nDimensionality of x\nnp::Int64\nDimensionality of p\ns::Int64\nOrder of TaylorSeries\nout::Vector{S} where S<:Real\nIn-place temporary storage for Taylor coefficient calculation\ny::Vector{S} where S<:Real\nVariables y = (x,p)\nx::Array{ForwardDiff.Dual{Nothing, S, NY}, 1} where {S<:Real, NY}\nState variables x\np::Array{ForwardDiff.Dual{Nothing, S, NY}, 1} where {S<:Real, NY}\nDecision variables p\nJxsto::Matrix{S} where S<:Real\nStorage for sum of Jacobian w.r.t x\nJpsto::Matrix{S} where S<:Real\nStorage for sum of Jacobian w.r.t p\ntjac::Matrix{S} where S<:Real\nTemporary for transpose of Jacobian w.r.t y\nJx::Array{Matrix{S}, 1} where S<:Real\nStorage for vector of Jacobian w.r.t x\nJp::Array{Matrix{S}, 1} where S<:Real\nStorage for vector of Jacobian w.r.t p\nresult::DiffResults.MutableDiffResult{1, Vector{S}, Tuple{Matrix{S}}} where S<:Real\nJacobian Result from DiffResults\ncfg::ForwardDiff.JacobianConfig{Nothing, S, NY, Tuple{Array{ForwardDiff.Dual{Nothing, S, NY}, 1}, Array{ForwardDiff.Dual{Nothing, S, NY}, 1}}} where {S<:Real, NY}\nJacobian Configuration for ForwardDiff\nxtaylor::Array{DynamicBoundspODEsDiscrete.StaticTaylorSeries.STaylor1{N, ForwardDiff.Dual{Nothing, S, NY}}, 1} where {N, S<:Real, NY}\nStore temporary STaylor1 vector for calculations\nxaux::Array{DynamicBoundspODEsDiscrete.StaticTaylorSeries.STaylor1{N, ForwardDiff.Dual{Nothing, S, NY}}, 1} where {N, S<:Real, NY}\nStore temporary STaylor1 vector for calculations\ndx::Array{DynamicBoundspODEsDiscrete.StaticTaylorSeries.STaylor1{N, ForwardDiff.Dual{Nothing, S, NY}}, 1} where {N, S<:Real, NY}\nStore temporary STaylor1 vector for calculations\ntaux::Array{DynamicBoundspODEsDiscrete.StaticTaylorSeries.STaylor1{N, T}, 1} where {N, T<:Real}\nt::Float64\nvnxt::Vector{Int64}\nIntermediate storage to avoid allocations in Taylor coefficient calc\nfnxt::Vector{Float64}\nIntermediate storage to avoid allocations in Taylor coefficient calc\n\n\n\n\n\n","category":"type"},{"location":"pODEsDiscrete/pODEsDiscrete.html#DynamicBoundspODEsDiscrete.jacobian_taylor_coeffs!","page":"Discrete-Time Differential Relaxations","title":"DynamicBoundspODEsDiscrete.jacobian_taylor_coeffs!","text":"jacobiantaylorcoeffs!\n\nComputes the Jacobian of the Taylor coefficients w.r.t. y = (x,p) storing the output inplace to result. A JacobianConfig object without tag checking, cfg, is required input and is initialized from cfg = ForwardDiff.JacobianConfig(nothing, out, y). The JacTaylorFunctor! used for the evaluation is g and inputs are x and p.\n\n\n\n\n\n","category":"function"},{"location":"pODEsDiscrete/pODEsDiscrete.html#DynamicBoundspODEsDiscrete.set_JxJp!","page":"Discrete-Time Differential Relaxations","title":"DynamicBoundspODEsDiscrete.set_JxJp!","text":"set_JxJp!\n\nExtracts the Jacobian of the Taylor coefficients w.r.t. x, Jx, and the Jacobian of the Taylor coefficients w.r.t. p, Jp, from result. The order of the Taylor series is s, the dimensionality of x is nx, the dimensionality of p is np, and tjac is preallocated storage for the transpose of the Jacobian w.r.t. y = (x,p).\n\n\n\n\n\n","category":"function"},{"location":"pODEsDiscrete/pODEsDiscrete.html#DynamicBoundspODEsDiscrete.LohnersFunctor","page":"Discrete-Time Differential Relaxations","title":"DynamicBoundspODEsDiscrete.LohnersFunctor","text":"LohnersFunctor\n\nA functor used in computing bounds and relaxations via Lohner's method. The implementation of the parametric Lohner's method described in the paper in (1) based on the non-parametric version given in (2).\n\n[Sahlodin, Ali M., and Benoit Chachuat. \"Discretize-then-relax approach for\n\nconvex/concave relaxations of the solutions of parametric ODEs.\" Applied Numerical Mathematics 61.7 (2011): 803-820.](https://www.sciencedirect.com/science/article/abs/pii/S0168927411000316)\n\n[R.J. Lohner, Computation of guaranteed enclosures for the solutions of\n\nordinary initial and boundary value problems, in: J.R. Cash, I. Gladwell (Eds.), Computational Ordinary Differential Equations, vol. 1, Clarendon Press, 1992, pp. 425–436.](http://www.goldsztejn.com/old-papers/Lohner-1992.pdf)\n\n\n\n\n\n","category":"type"},{"location":"pODEsDiscrete/pODEsDiscrete.html#DynamicBoundspODEsDiscrete.HermiteObreschkoffFunctor","page":"Discrete-Time Differential Relaxations","title":"DynamicBoundspODEsDiscrete.HermiteObreschkoffFunctor","text":"HermiteObreschkoffFunctor\n\nA functor used in computing bounds and relaxations via Hermite-Obreschkoff's method. The implementation of the parametric Hermite-Obreschkoff's method based on the non-parametric version given in (1).\n\n[Nedialkov NS, and Jackson KR. \"An interval Hermite-Obreschkoff method for\n\ncomputing rigorous bounds on the solution of an initial value problem for an ordinary differential equation.\" Reliable Computing 5.3 (1999): 289-310.](https://link.springer.com/article/10.1023/A:1009936607335)\n\n[Nedialkov NS. \"Computing rigorous bounds on the solution of an\n\ninitial value problem for an ordinary differential equation.\" University of Toronto. 2000.](http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.633.9654&rep=rep1&type=pdf)\n\n\n\n\n\n","category":"type"},{"location":"pODEsDiscrete/pODEsDiscrete.html#Existence-and-Uniqueness-Test-Utility-Functions","page":"Discrete-Time Differential Relaxations","title":"Existence and Uniqueness Test Utility Functions","text":"","category":"section"},{"location":"pODEsDiscrete/pODEsDiscrete.html","page":"Discrete-Time Differential Relaxations","title":"Discrete-Time Differential Relaxations","text":"improvement_condition\r\ncontains\r\nexcess_error\r\ncalc_alpha\r\nExistStorage{F,K,S,T}\r\nstate_contractor_k\r\nstate_contractor_γ\r\nstate_contractor_steps","category":"page"},{"location":"pODEsDiscrete/pODEsDiscrete.html#DynamicBoundspODEsDiscrete.improvement_condition","page":"Discrete-Time Differential Relaxations","title":"DynamicBoundspODEsDiscrete.improvement_condition","text":"improvement_condition\n\nFast check for to see if the ratio of the L∞ norm is improving in a given iteration using a hard-code ratio tolerance of 1.01. This is the improvement condition from Nedialko S. Nedialkov. Computing rigorous bounds on the solution of an initial value problem for an ordinary differential equation. 1999. Universisty of Toronto, PhD Dissertation, Algorithm 5.1, page 73-74).\n\n\n\n\n\n","category":"function"},{"location":"pODEsDiscrete/pODEsDiscrete.html#DynamicBoundspODEsDiscrete.contains","page":"Discrete-Time Differential Relaxations","title":"DynamicBoundspODEsDiscrete.contains","text":"contains\n\nChecks that an interval vector Vⱼ of length nx is contained in Uⱼ.\n\n\n\n\n\n","category":"function"},{"location":"pODEsDiscrete/pODEsDiscrete.html#DynamicBoundspODEsDiscrete.excess_error","page":"Discrete-Time Differential Relaxations","title":"DynamicBoundspODEsDiscrete.excess_error","text":"excess_error\n\nComputes the excess error using a norm-∞ of the diameter of the vectors.\n\n\n\n\n\n","category":"function"},{"location":"pODEsDiscrete/pODEsDiscrete.html#DynamicBoundspODEsDiscrete.calc_alpha","page":"Discrete-Time Differential Relaxations","title":"DynamicBoundspODEsDiscrete.calc_alpha","text":"calc_alpha\n\nComputes the stepsize for the adaptive step-routine.\n\n\n\n\n\n","category":"function"},{"location":"pODEsDiscrete/pODEsDiscrete.html#DynamicBoundspODEsDiscrete.ExistStorage","page":"Discrete-Time Differential Relaxations","title":"DynamicBoundspODEsDiscrete.ExistStorage","text":"ExistStorage{F,K,S,T}\n\nStorage used in the existence and uniqueness tests.\n\n\n\n\n\n","category":"type"},{"location":"pODEsDiscrete/pODEsDiscrete.html#DynamicBoundspODEsDiscrete.state_contractor_k","page":"Discrete-Time Differential Relaxations","title":"DynamicBoundspODEsDiscrete.state_contractor_k","text":"statecontractork(d::AbstractStateContractorName)\n\nRetrieves the order of the existence test to be used with\n\n\n\n\n\n","category":"function"},{"location":"pODEsDiscrete/pODEsDiscrete.html#DynamicBoundspODEsDiscrete.state_contractor_γ","page":"Discrete-Time Differential Relaxations","title":"DynamicBoundspODEsDiscrete.state_contractor_γ","text":"statecontractorγ(d::AbstractStateContractorName)\n\n\n\n\n\n","category":"function"},{"location":"pODEsDiscrete/pODEsDiscrete.html#DynamicBoundspODEsDiscrete.state_contractor_steps","page":"Discrete-Time Differential Relaxations","title":"DynamicBoundspODEsDiscrete.state_contractor_steps","text":"statecontractorsteps(d::AbstractStateContractorName)\n\n\n\n\n\n","category":"function"},{"location":"pODEsDiscrete/pODEsDiscrete.html#Utilities-for-overall-discretize-and-relaxation-scheme","page":"Discrete-Time Differential Relaxations","title":"Utilities for overall discretize-and-relaxation scheme","text":"","category":"section"},{"location":"pODEsDiscrete/pODEsDiscrete.html","page":"Discrete-Time Differential Relaxations","title":"Discrete-Time Differential Relaxations","text":"StepParams\r\nStepResult{S}\r\nContractorStorage{S}\r\nsingle_step!\r\nset_P!(d::DiscretizeRelax)\r\ncompute_X0!(d::DiscretizeRelax)\r\nset_Δ!","category":"page"},{"location":"pODEsDiscrete/pODEsDiscrete.html#DynamicBoundspODEsDiscrete.StepParams","page":"Discrete-Time Differential Relaxations","title":"DynamicBoundspODEsDiscrete.StepParams","text":"StepParams\n\nLEPUS and Integration parameters.\n\ntol::Float64\nError tolerance of integrator\nhmin::Float64\nMinimum stepsize\nrepeat_limit::Int64\nNumber of repetitions allowed for refinement\nis_adaptive::Bool\nIndicates an adaptive stepsize is used\nskip_step2::Bool\nIndicates the contractor step should be skipped\n\n\n\n\n\n","category":"type"},{"location":"pODEsDiscrete/pODEsDiscrete.html#DynamicBoundspODEsDiscrete.StepResult","page":"Discrete-Time Differential Relaxations","title":"DynamicBoundspODEsDiscrete.StepResult","text":"StepResult{S}\n\nResults passed to the next step.\n\nxⱼ::Vector{Float64}\nnominal value of the state variables\nXⱼ::Vector{S} where S\nrelaxations/bounds of the state variables\nA_Q::DynamicBoundspODEsDiscrete.FixedCircularBuffer{Matrix{Float64}}\nstorage for parallelepid enclosure of xⱼ\nA_inv::DynamicBoundspODEsDiscrete.FixedCircularBuffer{Matrix{Float64}}\nΔ::DynamicBoundspODEsDiscrete.FixedCircularBuffer{Vector{S}} where S\nstorage for parallelepid enclosure of xⱼ\npredicted_hj::Float64\npredicted step size for next step\ntime::Float64\nnew time\n\n\n\n\n\n","category":"type"},{"location":"pODEsDiscrete/pODEsDiscrete.html#DynamicBoundspODEsDiscrete.ContractorStorage","page":"Discrete-Time Differential Relaxations","title":"DynamicBoundspODEsDiscrete.ContractorStorage","text":"ContractorStorage{S}\n\nStorage used to hold inputs to the contractor method used.\n\n\n\n\n\n","category":"type"},{"location":"pODEsDiscrete/pODEsDiscrete.html#DynamicBoundspODEsDiscrete.single_step!","page":"Discrete-Time Differential Relaxations","title":"DynamicBoundspODEsDiscrete.single_step!","text":"single_step!\n\nPerforms a single-step of the validated integrator. Input stepsize is out.step.\n\n\n\n\n\n","category":"function"},{"location":"pODEsDiscrete/pODEsDiscrete.html#DynamicBoundspODEsDiscrete.set_P!-Tuple{DiscretizeRelax}","page":"Discrete-Time Differential Relaxations","title":"DynamicBoundspODEsDiscrete.set_P!","text":"set_P!(d::DiscretizeRelax)\n\nInitializes the P and rP (P - p) fields of d.\n\n\n\n\n\n","category":"method"},{"location":"pODEsDiscrete/pODEsDiscrete.html#DynamicBoundspODEsDiscrete.compute_X0!-Tuple{DiscretizeRelax}","page":"Discrete-Time Differential Relaxations","title":"DynamicBoundspODEsDiscrete.compute_X0!","text":"compute_X0!(d::DiscretizeRelax)\n\nInitializes the circular buffer that holds Δ with the out - mid(out) at index 1 and a zero vector at all other indices.\n\n\n\n\n\n","category":"method"},{"location":"pODEsDiscrete/pODEsDiscrete.html#DynamicBoundspODEsDiscrete.set_Δ!","page":"Discrete-Time Differential Relaxations","title":"DynamicBoundspODEsDiscrete.set_Δ!","text":"set_Δ!\n\nInitializes the circular buffer, Δ, that holds Δ_i with the out - mid(out) at index 1 and a zero vector at all other indices.\n\n\n\n\n\n","category":"function"},{"location":"Contributing/add_problem.html#How-to-Add-a-Problem-Type","page":"How to Add a Problem Type","title":"How to Add a Problem Type","text":"","category":"section"},{"location":"Contributing/add_problem.html#.-Define-the-problem-type-(and-possibly-an-abstract-supertype)","page":"How to Add a Problem Type","title":"1. Define the problem type (and possibly an abstract supertype)","text":"","category":"section"},{"location":"Contributing/add_problem.html","page":"How to Add a Problem Type","title":"How to Add a Problem Type","text":"Each problem type should be an subtype of the AbstractDERelaxProblem or an abstract subtype of AbstractDERelaxProblem. At a minimum the following, attributes should be supported by each problem type.","category":"page"},{"location":"Contributing/add_problem.html","page":"How to Add a Problem Type","title":"How to Add a Problem Type","text":"DynamicBoundsBase.StateNumber\r\nDynamicBoundsBase.ParameterNumber\r\nDynamicBoundsBase.SupportNumber\r\nDynamicBoundsBase.ConstantParameterValue","category":"page"},{"location":"Contributing/add_problem.html#.-Define-set!/get-functions","page":"How to Add a Problem Type","title":"2. Define set!/get functions","text":"","category":"section"},{"location":"Contributing/add_problem.html","page":"How to Add a Problem Type","title":"How to Add a Problem Type","text":"Additional set!/get functions should be added to support any optional information pertinent to the problem type.","category":"page"},{"location":"Contributing/add_problem.html#.-Define-a-default-local-integrator-algorithm.","page":"How to Add a Problem Type","title":"3. Define a default local integrator algorithm.","text":"","category":"section"},{"location":"Contributing/add_problem.html","page":"How to Add a Problem Type","title":"How to Add a Problem Type","text":"It's recommended that a general integrate! function should be defined for each problem type. This eliminates the need to associate an local integration algorithm with each algorithm used to compute relaxations and bounds of systems of differential equations.","category":"page"},{"location":"getting_started.html#Getting-Started","page":"Getting Started","title":"Getting Started","text":"","category":"section"},{"location":"getting_started.html","page":"Getting Started","title":"Getting Started","text":"The including integrators used by constructing a relaxation problem. Then by adding attributes to the relaxation problem and building the integrator from the relaxation problem. The integrator may then be modified by using the base API. Lastly, the relax!/integrate! are called to compute information about the trajectories and this information is retrieved using API functions.","category":"page"},{"location":"getting_started.html#Setting-up-a-relaxation-problem","page":"Getting Started","title":"Setting up a relaxation problem","text":"","category":"section"},{"location":"getting_started.html","page":"Getting Started","title":"Getting Started","text":"We begin by constructing a relaxation problem. Currently, the ODERelaxProb is used for all parametric ODEs but specialized variants of this will become available in the future. This manner of relaxation problem is specified using the right-hand side function f! (evaluated in place) along with a function of p defining the initial conditions. A time span and box constraints on p are also expected.","category":"page"},{"location":"getting_started.html","page":"Getting Started","title":"Getting Started","text":"using DynamicBounds\r\n\r\nfunction f!(dx, x, p, t)\r\n    dx[1] = -p[1]*x[1]*x[2] + p[2]*x[3] + p[6]*x[6]\r\n    dx[2] = -p[1]*x[1]*x[2] + p[2]*x[3] + p[3]*x[3]\r\n    dx[3] =  p[1]*x[1]*x[2] - p[2]*x[3] - p[3]*x[3]\r\n    dx[4] =  p[3]*x[3] - p[4]*x[4]*x[5] + p[5]*x[6]\r\n    dx[5] = -p[4]*x[4]*x[5] + p[5]*x[6] + p[6]*x[6]\r\n    dx[6] =  p[4]*x[4]*x[5] - p[5]*x[6] - p[6]*x[6]\r\n    return\r\nend\r\nx0(p) = [34.0, 20.0, 0.0, 0.0, 16.0, 0.0]\r\n\r\ntspan = (0.0, 18.0e-5*250)\r\npL = [0.1; 0.033; 16.0; 5.0; 0.5; 0.3]\r\npU = 10.0*pL\r\n\r\node_prob = ODERelaxProb(f!, x0, tspan, pL, pU)","category":"page"},{"location":"getting_started.html","page":"Getting Started","title":"Getting Started","text":"We can often further refine bounds/relaxation on the state variables by making use of invariants and apriori bounds/relaxations. We'll add a polyhedral invariant and apriori bounds state bounds.","category":"page"},{"location":"getting_started.html","page":"Getting Started","title":"Getting Started","text":"M = [0.0 -1.0 -1.0  0.0  0.0  0.0;\r\n     0.0  0.0  0.0  0.0 -1.0 -1.0;\r\n     1.0 -1.0  0.0  1.0 -1.0  0.0]\r\nb = [-20.0; -16.0; -2.0]\r\npolyhedral_invariant = PolyhedralConstraint(M, :==, b)\r\nset!(ode_prob, polyhedral_invariant)\r\n\r\nu_lo = zeros(6)\r\nu_hi = [34.0; 20.0; 20.0; 34.0; 16.0; 16.0]\r\nset!(prob, ConstantBounds(u_lo, u_hi))","category":"page"},{"location":"getting_started.html","page":"Getting Started","title":"Getting Started","text":"We now can specify the points at which we want to retrieve information about state variables by adding a QueriedSupport attribute to the problem","category":"page"},{"location":"getting_started.html","page":"Getting Started","title":"Getting Started","text":"set!(prob, QueriedSupport(range(tspan[1], tspan[2], length = 50)))","category":"page"},{"location":"getting_started.html#Creating-an-integrator-from-the-problem","page":"Getting Started","title":"Creating an integrator from the problem","text":"","category":"section"},{"location":"getting_started.html","page":"Getting Started","title":"Getting Started","text":"The integrator is built from the relaxation problem along with keyword variables.","category":"page"},{"location":"getting_started.html","page":"Getting Started","title":"Getting Started","text":"integrator = DifferentialInequality(ode_prob, calculate_relax = true,\r\n                                              calculate_subgradient = false)","category":"page"},{"location":"getting_started.html","page":"Getting Started","title":"Getting Started","text":"Provided that we're interested in computing relaxations as well as constant bounds (w.r.t p) we'll need to specify parameter values within the box constraints.","category":"page"},{"location":"getting_started.html","page":"Getting Started","title":"Getting Started","text":"setall!(integrator, ParameterValue(), p)","category":"page"},{"location":"getting_started.html","page":"Getting Started","title":"Getting Started","text":"Relaxation problems also support the ParameterValue attributes. However, it's often preferable to set the value in the integrator to avoid rebuilding the integrator each time.","category":"page"},{"location":"getting_started.html#Computing-relaxations-and-trajectories","page":"Getting Started","title":"Computing relaxations and trajectories","text":"","category":"section"},{"location":"getting_started.html","page":"Getting Started","title":"Getting Started","text":"We now compute the relevant information about the state variables and the solution of the pODEs.","category":"page"},{"location":"getting_started.html","page":"Getting Started","title":"Getting Started","text":"relax!(integrator)      # compute relaxations\r\nintegrate!(integrator)  # compute trajectories","category":"page"},{"location":"getting_started.html#Querying-the-integrator/problem-for-information","page":"Getting Started","title":"Querying the integrator/problem for information","text":"","category":"section"},{"location":"getting_started.html","page":"Getting Started","title":"Getting Started","text":"We can now query functions using the get API function.","category":"page"},{"location":"getting_started.html","page":"Getting Started","title":"Getting Started","text":"val = get(integrator, Value(3))\r\nlo = get(integrator, Bound{Lower}(3))\r\nhi = get(integrator, Bound{Upper}(3))\r\ncv = get(integrator, Relaxation{Lower}(3))\r\ncc = get(integrator, Relaxation{Upper}(3))","category":"page"},{"location":"getting_started.html#Use-the-sample-problem-library","page":"Getting Started","title":"Use the sample problem library","text":"","category":"section"},{"location":"getting_started.html","page":"Getting Started","title":"Getting Started","text":"DE_keys = keys(LibRelaxODE.STANDARD_LIBRARY)\r\nfor i = 1:length(keys)\r\n    prob = LibRelaxODE.STANDARD_LIBRARY(DE_keys[i])\r\n    integrator = DifferentialInequality(prob)\r\n    relax!(integrator)\r\nend","category":"page"},{"location":"Contributing/contributing.html#How-to-Contribute","page":"How to Contribute","title":"How to Contribute","text":"","category":"section"},{"location":"Contributing/contributing.html","page":"How to Contribute","title":"How to Contribute","text":"We're always happy to welcome work with additional collaborators and contributors. One of the easy ways for newcomers to contribute is by adding additional relaxations.","category":"page"},{"location":"Contributing/contributing.html","page":"How to Contribute","title":"How to Contribute","text":"If you're interested in contributing in larger ways, please contact: Matthew Wilhelm","category":"page"},{"location":"Contributing/contributing.html","page":"How to Contribute","title":"How to Contribute","text":"If you have any requests for additional functionality, bug fixes, or comments please feel free to open a new issue using Github issue tracker.","category":"page"},{"location":"pODEsIneq/pODEsIneq.html#**DynamicBoundspODEsIneq.jl**:-Continuous-time-relaxations/bounds-of-nonlinear-parametric-differential-equations","page":"Continuous-Time Differential Relaxations","title":"DynamicBoundspODEsIneq.jl: Continuous-time relaxations/bounds of nonlinear parametric differential equations","text":"","category":"section"},{"location":"pODEsIneq/pODEsIneq.html#Callback-functions-used-in-constructing-the-continuous-time-differential-inequalities.","page":"Continuous-Time Differential Relaxations","title":"Callback functions used in constructing the continuous time differential inequalities.","text":"","category":"section"},{"location":"pODEsIneq/pODEsIneq.html","page":"Continuous-Time Differential Relaxations","title":"Continuous-Time Differential Relaxations","text":"DifferentialInequalityCond\r\nDifferentialInequalityAffect\r\nDifferentialInequalityAffectNeg\r\nDifferentialInequalityf{Z, F}","category":"page"},{"location":"pODEsIneq/pODEsIneq.html#DynamicBoundspODEsIneq.DifferentialInequalityCond","page":"Continuous-Time Differential Relaxations","title":"DynamicBoundspODEsIneq.DifferentialInequalityCond","text":"DifferentialInequalityCond <: Function\n\nA functor (<: Function) used to check for an event were a relaxation ODE crosses the an interval bound ODE. The functor is called using (d::DifferentialInequalityCond)(g, x, t, integrator). The p field of the integrator hold parameter values in components 1, ..., np. Components np + 1, ..., 2np are a flag is indicating a positive crossing. Components 2np + 1, ..., 3*np are a flag is indicating a negative crossing.\n\n\n\n\n\n","category":"type"},{"location":"pODEsIneq/pODEsIneq.html#DynamicBoundspODEsIneq.DifferentialInequalityAffect","page":"Continuous-Time Differential Relaxations","title":"DynamicBoundspODEsIneq.DifferentialInequalityAffect","text":"DifferentialInequalityAffect <: Function\n\nA functor (<: Function) that sets an indicator parameter to zero if a positive event crossing occurs.\n\n\n\n\n\n","category":"type"},{"location":"pODEsIneq/pODEsIneq.html#DynamicBoundspODEsIneq.DifferentialInequalityAffectNeg","page":"Continuous-Time Differential Relaxations","title":"DynamicBoundspODEsIneq.DifferentialInequalityAffectNeg","text":"DifferentialInequalityAffectNeg <: Function\n\nA functor (<: Function) that sets an indicator parameter to zero if a negative event crossing occurs.\n\n\n\n\n\n","category":"type"},{"location":"pODEsIneq/pODEsIneq.html#DynamicBoundspODEsIneq.DifferentialInequalityf","page":"Continuous-Time Differential Relaxations","title":"DynamicBoundspODEsIneq.DifferentialInequalityf","text":"DifferentialInequalityf{Z, F} <: Function\n\nA functor (<: Function) used to evaluate the r.h.s of the differential inequality. The following constructor is used to initialize it: DifferentialInequalityf(f!, Z, nx, np, P, relax, subgrad, polyhedral_constraint, Xapriori).\n\nf!::Any\nRight-hand side function\nnx::Int64\nNumber of state variables\nnm::Int64\nDimensionality of polyhedral constraints.\nnp::Int64\nNumber of decision variables\np_mc::Vector{Z} where Z\nDecision variable relaxation storage\nP::Vector{IntervalArithmetic.Interval{Float64}}\nDecision variable interval bounds\nX::Vector{IntervalArithmetic.Interval{Float64}}\nConstraint state variable interval bounds\nx_mc::Vector{Z} where Z\nInput State Variable Temporary Storage\nxout_mc::Vector{Z} where Z\nOutput State Variable Temporary Storage\nBetaL::Vector{IntervalArithmetic.Interval{Float64}}\nTemporary Storage for Lower Beta\nBetaU::Vector{IntervalArithmetic.Interval{Float64}}\nTemporary Storage for Upper Beta\nxout_intv1::Vector{IntervalArithmetic.Interval{Float64}}\nTemporary Storage\nxout_intv2::Vector{IntervalArithmetic.Interval{Float64}}\nTemporary Storage\ncalculate_relax::Bool\nIndicates that relaxations should be computed.\ncalculate_subgradient::Bool\nIndicates that subgradients should be computed (calculate_relax must be true).\nprng::UnitRange{Int64}\nxrng::UnitRange{Int64}\npolyhedral_constraint::Union{Nothing, PolyhedralConstraint}\nPolyhedral constraint used\nhas_apriori::Bool\nXapriori::Vector{IntervalArithmetic.Interval{Float64}}\nparams::Vector{Float64}\nConstant value parameters\nhas_params::Bool\n\n\n\n\n\n","category":"type"},{"location":"pODEsIneq/pODEsIneq.html#Integrator-used-for-constructing-continuous-time-differential-inequality-bounds/relaxations.","page":"Continuous-Time Differential Relaxations","title":"Integrator used for constructing continuous time differential inequality bounds/relaxations.","text":"","category":"section"},{"location":"pODEsIneq/pODEsIneq.html","page":"Continuous-Time Differential Relaxations","title":"Continuous-Time Differential Relaxations","text":"DifferentialInequality","category":"page"},{"location":"pODEsIneq/pODEsIneq.html#DynamicBoundspODEsIneq.DifferentialInequality","page":"Continuous-Time Differential Relaxations","title":"DynamicBoundspODEsIneq.DifferentialInequality","text":"mutable struct DifferentialInequality{F, N, T<:McCormick.RelaxTag, PRB1<:SciMLBase.AbstractODEProblem, INT1, CB<:SciMLBase.AbstractContinuousCallback} <: AbstractODERelaxIntegrator\n\nThe DifferentialInequality type integrator represents the relaxed pODE problem as a 2nx dimension ODE problem if calculate_relax is false, a 4nx dimension ODE problem if calculate_relax is true and 4*nx + 4*np*nx if calculate_subgradients is also set to true.\n\nx[1:nx] are the lower interval bounds\nx[(1+nx):2*nx] are upper interval bounds\nx[(1+2*nx):3*nx] are convex relaxations (computed if calculate_relax = true)\nx[(1+3*nx):4*nx] are concave relaxations (computed if calculate_relax = true)\nx[(1+4*nx):(4+np)*nx] are subgradients of the convex relaxations (computed if calculate_subgradients = true)\nx[(1+(4+np)*nx):(4+2*np)*nx] are subgradients of the concave relaxations (computed if calculate_subgradients = true)\n\nThe first np parameter values correspond to the parameter values in the original problem. If (calculate_relax == true) then (np+1):(np+nx) parameter values correspond to the b_i^c variables used to detect a relaxation crossing a lower state bound. The (np+nx+1):(np+nx) parameter values correspond to the b_i^C variables used to detect a relaxation crossing a upper state bound. The variables are floats but are valued 0.0 and 1.0 and can be intepreted as the corresponding 0-1 Boolean values. Otherwise, only np parameter values are used.\n\ncalculate_relax::Bool\ncalculate_subgradient::Bool\ncalculate_local_sensitivity::Bool\ndifferentiable::Bool\nevent_soft_tol::Float64\nparams::Vector{Float64}\np::Vector{Float64}\npL::Vector{Float64}\npU::Vector{Float64}\np_mc::Array{McCormick.MC{N, T}, 1} where {N, T<:McCormick.RelaxTag}\nx0f::Any\nx0::Vector{Float64}\nx0_mc::Array{McCormick.MC{N, T}, 1} where {N, T<:McCormick.RelaxTag}\nxL::ElasticArrays.ElasticMatrix{Float64, V} where V<:DenseVector{Float64}\nxU::ElasticArrays.ElasticMatrix{Float64, V} where V<:DenseVector{Float64}\nrelax_ode_prob::SciMLBase.AbstractODEProblem\nrelax_ode_integrator::Any\nrelax_t::Vector{Float64}\nrelax_lo::ElasticArrays.ElasticMatrix{Float64, V} where V<:DenseVector{Float64}\nrelax_hi::ElasticArrays.ElasticMatrix{Float64, V} where V<:DenseVector{Float64}\nrelax_cv::ElasticArrays.ElasticMatrix{Float64, V} where V<:DenseVector{Float64}\nrelax_cc::ElasticArrays.ElasticMatrix{Float64, V} where V<:DenseVector{Float64}\nrelax_cv_grad::ElasticArrays.ElasticArray{StaticArrays.SVector{N, Float64}, 2, 1, V} where {N, V<:DenseArray{StaticArrays.SVector{N, Float64}, 1}}\nrelax_cc_grad::ElasticArrays.ElasticArray{StaticArrays.SVector{N, Float64}, 2, 1, V} where {N, V<:DenseArray{StaticArrays.SVector{N, Float64}, 1}}\nrelax_mc::ElasticArrays.ElasticArray{McCormick.MC{N, T}, 2, 1, V} where {N, T<:McCormick.RelaxTag, V<:DenseArray{McCormick.MC{N, T}, 1}}\nvector_callback::SciMLBase.AbstractContinuousCallback\nintegrator_state::IntegratorStates\nlocal_problem_storage::Any\nnp::Int64\nnx::Int64\nnt::Int64\nrelax_t_dict_flt::Dict{Float64, Int64}\nrelax_t_dict_indx::Dict{Int64, Int64}\npolyhedral_constraint::Union{Nothing, PolyhedralConstraint}\nhas_params::Bool\nprob::ODERelaxProb\n\n\n\n\n\n","category":"type"},{"location":"Contributing/add_integrator.html#How-to-Add-an-Integrator","page":"How to Add an Integrator","title":"How to Add an Integrator","text":"","category":"section"},{"location":"Contributing/add_integrator.html","page":"How to Add an Integrator","title":"How to Add an Integrator","text":"In order to add a custom integrator for a novel relaxation method, following the procedure outlined below. ","category":"page"},{"location":"Contributing/add_integrator.html#.-Define-the-integrator-type-(and-possibly-an-abstract-supertype)","page":"How to Add an Integrator","title":"1. Define the integrator type (and possibly an abstract supertype)","text":"","category":"section"},{"location":"Contributing/add_integrator.html","page":"How to Add an Integrator","title":"How to Add an Integrator","text":"An integrator structure is defined which holds all relevant information relating to problem inputs and relaxation outputs. This structure should be a subtype of the integrator type assocaited with the appropriate relaxation problem (e.g. <: INTEGRATOR_TYPE <: AbstractDERelaxIntegrator).","category":"page"},{"location":"Contributing/add_integrator.html","page":"How to Add an Integrator","title":"How to Add an Integrator","text":"mutable struct NewIntegrator <: INTEGRATOR_TYPE ... end","category":"page"},{"location":"Contributing/add_integrator.html","page":"How to Add an Integrator","title":"How to Add an Integrator","text":"A constructor should also be defined which builds the integrator for each supported problem type (PROBLEM_TYPE). ","category":"page"},{"location":"Contributing/add_integrator.html","page":"How to Add an Integrator","title":"How to Add an Integrator","text":"function NewIntegrator(prob::PROBLEM_TYPE) ... end","category":"page"},{"location":"Contributing/add_integrator.html#.-Define-set!/support/get-functions","page":"How to Add an Integrator","title":"2. Define set!/support/get functions","text":"","category":"section"},{"location":"Contributing/add_integrator.html","page":"How to Add an Integrator","title":"How to Add an Integrator","text":"At a minimum the following methods should be defined for each integrator in order to allow users to  input and query information. Each integrator should define the following functions at a minimum:","category":"page"},{"location":"Contributing/add_integrator.html","page":"How to Add an Integrator","title":"How to Add an Integrator","text":"DynamicBoundsBase.supports(d::NewIntegrator, t::DynamicBoundsBase.Bound{Lower})\r\nDynamicBoundsBase.supports(d::NewIntegrator, t::DynamicBoundsBase.Bound{Upper})\r\nDynamicBoundsBase.supports(d::NewIntegrator, t::DynamicBoundsBase.IsNumeric)\r\nDynamicBoundsBase.supports(d::NewIntegrator, t::DynamicBoundsBase.IsSolutionSet)\r\nDynamicBoundsBase.supports(d::NewIntegrator, t::DynamicBoundsBase.TerminationStatus)\r\nDynamicBoundsBase.supports(d::NewIntegrator, t::DynamicBoundsBase.Value)\r\nDynamicBoundsBase.supports(d::NewIntegrator, t::DynamicBoundsBase.ParameterBound{Lower})\r\nDynamicBoundsBase.supports(d::NewIntegrator, t::DynamicBoundsBase.ParameterBound{Upper})\r\nDynamicBoundsBase.supports(d::NewIntegrator, t::DynamicBoundsBase.ParameterValue)\r\nDynamicBoundsBase.supports(d::NewIntegrator, t::DynamicBoundsBase.SupportSet)\r\nDynamicBoundsBase.supports(d::NewIntegrator, t::DynamicBoundsBase.ParameterNumber)\r\nDynamicBoundsBase.supports(d::NewIntegrator, t::DynamicBoundsBase.StateNumber)\r\nDynamicBoundsBase.supports(d::NewIntegrator, t::DynamicBoundsBase.SupportNumber)\r\nDynamicBoundsBase.supports(td::NewIntegrator, t::DynamicBoundsBase.LocalSensitivityOn)","category":"page"},{"location":"Contributing/add_integrator.html","page":"How to Add an Integrator","title":"How to Add an Integrator","text":"DynamicBoundsBase.set!(d::NewIntegrator, t::DynamicBoundsBase.ParameterBound{Lower}, x)\r\nDynamicBoundsBase.set!(d::NewIntegrator, t::DynamicBoundsBase.ParameterBound{Upper}, x)\r\nDynamicBoundsBase.set!(d::NewIntegrator, t::DynamicBoundsBase.ParameterValue, x)\r\nDynamicBoundsBase.set!(d::NewIntegrator, t::DynamicBoundsBase.ConstantParameterValue, x)\r\nDynamicBoundsBase.set!(d::NewIntegrator, t::DynamicBoundsBase.LocalSensitivityOn, x)","category":"page"},{"location":"Contributing/add_integrator.html","page":"How to Add an Integrator","title":"How to Add an Integrator","text":"DynamicBoundsBase.get(d::NewIntegrator, t::DynamicBoundsBase.ParameterNumber)\r\nDynamicBoundsBase.get(d::NewIntegrator, t::DynamicBoundsBase.SupportSet)\r\nDynamicBoundsBase.get(d::NewIntegrator, t::DynamicBoundsBase.ParameterBound{Lower})\r\nDynamicBoundsBase.get(d::NewIntegrator, t::DynamicBoundsBase.ParameterBound{Upper})\r\n\r\nDynamicBoundsBase.get(d::NewIntegrator, t::DynamicBoundsBase.Bound{Lower})\r\nDynamicBoundsBase.get(d::NewIntegrator, t::DynamicBoundsBase.Bound{Upper})\r\nDynamicBoundsBase.get(d::NewIntegrator, t::DynamicBoundsBase.Subgradient{Lower})\r\nDynamicBoundsBase.get(d::NewIntegrator, t::DynamicBoundsBase.Subgradient{Upper})\r\n\r\nDynamicBoundsBase.get(d::NewIntegrator, t::DynamicBoundsBase.Value)\r\nDynamicBoundsBase.get(d::NewIntegrator, t::DynamicBoundsBase.Gradient{Nominal})\r\n\r\nDynamicBoundsBase.get(d::DifferentialInequality, t::DynamicBoundsBase.IsNumeric)\r\nDynamicBoundsBase.get(d::DifferentialInequality, t::DynamicBoundsBase.IsSolutionSet)\r\nDynamicBoundsBase.get(d::DifferentialInequality, t::DynamicBoundsBase.TerminationStatus)","category":"page"},{"location":"Contributing/add_integrator.html","page":"How to Add an Integrator","title":"How to Add an Integrator","text":"Additionally, integrators that support computing relaxations in addition to normal bounds should implement the following methods:","category":"page"},{"location":"Contributing/add_integrator.html","page":"How to Add an Integrator","title":"How to Add an Integrator","text":"DynamicBoundsBase.supports(d::NewIntegrator, t::DynamicBoundsBase.Relaxation{Lower})\r\nDynamicBoundsBase.supports(d::NewIntegrator, t::DynamicBoundsBase.Relaxation{Upper})\r\nDynamicBoundsBase.get(d::NewIntegrator, t::DynamicBoundsBase.Relaxation{Lower})\r\nDynamicBoundsBase.get(d::NewIntegrator, t::DynamicBoundsBase.Relaxation{Upper})","category":"page"},{"location":"Contributing/add_integrator.html#.-Define-a-relaxation-algorithm","page":"How to Add an Integrator","title":"3. Define a relaxation algorithm","text":"","category":"section"},{"location":"Contributing/add_integrator.html","page":"How to Add an Integrator","title":"How to Add an Integrator","text":"A method, relax! should be defined to compute bounds/relaxation wherein information pertaining to the bounds/relaxations is stored to d::NewIntegrator.","category":"page"},{"location":"Contributing/add_integrator.html","page":"How to Add an Integrator","title":"How to Add an Integrator","text":"function relax!(d::NewIntegrator) end","category":"page"},{"location":"Contributing/add_integrator.html#.-(Optional)-Define-an-integrator-specific-local-integration-scheme","page":"How to Add an Integrator","title":"4. (Optional) Define an integrator specific local integration scheme","text":"","category":"section"},{"location":"Contributing/add_integrator.html","page":"How to Add an Integrator","title":"How to Add an Integrator","text":"This is primarily important when defining relaxation and boundsing methods for  numerical solution of a differential system wherein truncuation error from mismatching relaxation and integration methods is a concern. For integrators associated new problem types, it is encourage to include a integrate! method for the associated abstract type. ","category":"page"},{"location":"Contributing/add_integrator.html","page":"How to Add an Integrator","title":"How to Add an Integrator","text":"function integrate!(d::NewIntegrator) end","category":"page"},{"location":"ref.html#**References**","page":"References","title":"References","text":"","category":"section"},{"location":"ref.html#*Continuous-Time-Methods*","page":"References","title":"Continuous-Time Methods","text":"","category":"section"},{"location":"ref.html","page":"References","title":"References","text":"Scott JK, Barton PI (2013), Bounds on the reachable sets of nonlinear control systems, Automatica 49 (1), 93-100.\nScott JK, Barton PI (2013), Improved relaxations for the parametric solutions of ODEs using differential inequalities, Journal of Global Optimization, 1-34.\nScott JK (2012), Reachability Analysis and Deterministic Global Optimization of Differential-Algebraic Systems, Massachusetts Institute of Technology.\nShen K, Scott JK (2017), Rapid and accurate reachability analysis for nonlinear dynamic systems by exploiting model redundancy, Computers & Chemical Engineering 106, 596-608.","category":"page"},{"location":"ref.html#*Discrete-Time-Methods*","page":"References","title":"Discrete-Time Methods","text":"","category":"section"},{"location":"ref.html","page":"References","title":"References","text":"Corliss GF, and Rihm R (1996). Validating an a priori enclosure using high-order Taylor series. MATHEMATICAL RESEARCH, 90, 228-238.\nLohner RJ (1992). Computation of guaranteed enclosures for the solutions of ordinary initial and boundary value problems. In Institute of mathematics and its applications conference series. Oxford University Press. Vol. 39: 425-425.\nNedialkov NS, and Jackson KR (1999). An interval Hermite-Obreschkoff method for computing rigorous bounds on the solution of an initial value problem for an ordinary differential equation. Reliable Computing 5.3: 289-310.\nNedialkov NS (2000). Computing rigorous bounds on the solution of an initial value problem for an ordinary differential equation. University of Toronto.\nNedialkov NS, & Jackson KR (2000). ODE software that computes guaranteed bounds on the solution. In Advances in Software Tools for Scientific Computing (pp. 197-224). Springer, Berlin, Heidelberg.\nSahlodin AM, & Chachuat B. (2011). Discretize-then-relax approach for convex/concave relaxations of the solutions of parametric ODEs. Applied Numerical Mathematics, 61(7), 803-820.\nWilhelm, ME, Le AV, & Stuber, MD (2019). Global optimization of stiff dynamical systems. AIChE Journal, 65(12), e16836.","category":"page"},{"location":"index.html#**DynamicBounds.jl**","page":"Introduction","title":"DynamicBounds.jl","text":"","category":"section"},{"location":"index.html#Authors","page":"Introduction","title":"Authors","text":"","category":"section"},{"location":"index.html","page":"Introduction","title":"Introduction","text":"Matthew Wilhelm, Department of Chemical and Biomolecular Engineering,  University of Connecticut (UCONN)","category":"page"},{"location":"index.html#Overview","page":"Introduction","title":"Overview","text":"","category":"section"},{"location":"index.html","page":"Introduction","title":"Introduction","text":"DynamicBounds.jl is a package for computing relaxations and interval bounds of parametric state solutions of ordinary differential equations in the Julia language. By employing an interface to DifferentialEquations.jl, this package allows for the construction of well-posed mathematical problems in which the relaxations of parametric differential equations can be computed. Further, this allows for the association of such problems with a particular integration scheme for the evaluation of solution trajectories at user-specified parameter values. The use of a simple extensible API allows for the association of additional information with particular problem type, such as the incorporation of nonlinear and affine invariants. Moreover, this facilitates higher-order algorithms (e.g., global dynamic optimization) by allowing information to be queried in a standard manner from computed state bounds and relaxations.","category":"page"},{"location":"index.html#Installing-DynamicBounds.jl","page":"Introduction","title":"Installing DynamicBounds.jl","text":"","category":"section"},{"location":"index.html","page":"Introduction","title":"Introduction","text":"DynamicBounds.jl is registered Julia package. It can be installed using the Julia package manager. From the Julia REPL, type ] to enter the Pkg REPL mode and run the following command","category":"page"},{"location":"index.html","page":"Introduction","title":"Introduction","text":"pkg> add DynamicBounds","category":"page"},{"location":"index.html#Subpackages:","page":"Introduction","title":"Subpackages:","text":"","category":"section"},{"location":"index.html","page":"Introduction","title":"Introduction","text":"DynamicBoundsBase.jl: The backend package which provides an abstraction layer define attributes for problem types, integrators, and the handling of access functions (set!/get/setall!/getall!).\nDynamicBoundspODEsIneq.jl: An implementation of the continuous-time differential inequality algorithms for constructing interval state bounds and state relaxations of parametric ordinary differential equation systems (pODEs).\nDynamicBoundspODEsDiscrete.jl: An implementation of various discrete-time algorithms (Hermite-Obreschkoff, Lohner's Method, e.g.) for constructing interval state bounds and state relaxations of parametric ordinary differential equation systems (pODEs)","category":"page"},{"location":"index.html#Citing-DynamicBounds.jl","page":"Introduction","title":"Citing DynamicBounds.jl","text":"","category":"section"},{"location":"index.html","page":"Introduction","title":"Introduction","text":"A paper about the DynamicBounds.jl software package is currently under preparation. In the meantime, please feel free to cite the conference presentation below:","category":"page"},{"location":"index.html","page":"Introduction","title":"Introduction","text":"@misc{Wilhelm2020,\n  author = {Wilhelm, M.E.},\n  title = {DynamicBounds.jl},\n  year = {2020},\n  publisher = {GitHub},\n  journal = {GitHub repository},\n  howpublished = {https://github.com/PSORLab/DynamicBounds.jl}\n}","category":"page"},{"location":"Base/Base.html#**DynamicBoundsBase.jl**:-An-extensible-abstraction-layer-for-DynamicBounds","page":"DynamicsBoundsBase, An extendable abstraction layer","title":"DynamicBoundsBase.jl: An extensible abstraction layer for DynamicBounds","text":"","category":"section"},{"location":"Base/Base.html#**Current-supported-problem-types-and-constructors:**","page":"DynamicsBoundsBase, An extendable abstraction layer","title":"Current supported problem types and constructors:","text":"","category":"section"},{"location":"Base/Base.html","page":"DynamicsBoundsBase, An extendable abstraction layer","title":"DynamicsBoundsBase, An extendable abstraction layer","text":"AbstractDERelaxProblem\r\nAbstractODERelaxProblem\r\nODERelaxProb{F,JX,JP,xType,K}","category":"page"},{"location":"Base/Base.html#DynamicBoundsBase.AbstractDERelaxProblem","page":"DynamicsBoundsBase, An extendable abstraction layer","title":"DynamicBoundsBase.AbstractDERelaxProblem","text":"abstract type AbstractDERelaxProblem\n\nAbstract supertype for all relaxation problems.\n\n\n\n\n\n","category":"type"},{"location":"Base/Base.html#DynamicBoundsBase.AbstractODERelaxProblem","page":"DynamicsBoundsBase, An extendable abstraction layer","title":"DynamicBoundsBase.AbstractODERelaxProblem","text":"AbstractODERelaxProblem\n\nAbstract type for problems used to construct relaxations of parametric ODEs.\n\n\n\n\n\n","category":"type"},{"location":"Base/Base.html#DynamicBoundsBase.ODERelaxProb","page":"DynamicsBoundsBase, An extendable abstraction layer","title":"DynamicBoundsBase.ODERelaxProb","text":"mutable struct ODERelaxProb{F, JX, JP, xType, K} <: AbstractODERelaxProblem\n\nA structure used to hold a parametric ODEs problem.\n\nf::Any\nRight-hand side function.\nJx!::Any\nJacobian of rhs w.r.t x.\nJp!::Any\nJacobian of rhs w.r.t p.\nx0::Any\nInitial condition function.\nxL::Vector{Float64}\nLower constant state bound storage.\nxU::Vector{Float64}\nUpper constant state bound storage.\ntspan::Tuple{Float64, Float64}\nTime span of integration.\ntsupports::Vector{Float64}\nSupport points: Points 'x' values will be queried.\np::Vector{Float64}\nPoint to relax/bound in over the decision space.\npL::Vector{Float64}\nLower bounds of the decision space.\npU::Vector{Float64}\nUpper bounds of the decision space.\nuser_Jx::Bool\nProblem has a user-defined Jacobian of the rhs w.r.t x\nuser_Jp::Bool\nProblem has a user-defined Jacobian of the rhs w.r.t p\nuser_state_bnd::Bool\nConstant user state bounds have been set\nvariable_state_bnd::Bool\nVariable user state bounds have been set\nnx::Int64\nState space dimension\nnp::Int64\nDecision space dimension\nparams::Vector{Float64}\nOptional keywork argument: Indicates the rhs function and the initial     condition function take an additional argument param. For example,     it is now f!(dx, x, p, param).\npolyhedral_constraint::Union{Nothing, PolyhedralConstraint}\nStorage for polyhedral constraint, if any\nconstant_state_bounds::Union{Nothing, ConstantStateBounds}\nStorage for the constant state bounds, if any\nsupport_set::SupportSet{Float64}\nThe support set if used\nkwargs::Any\nAdditional keyword arguments\n\n\n\n\n\n","category":"type"},{"location":"Base/Base.html#Problem-attributes","page":"DynamicsBoundsBase, An extendable abstraction layer","title":"Problem attributes","text":"","category":"section"},{"location":"Base/Base.html","page":"DynamicsBoundsBase, An extendable abstraction layer","title":"DynamicsBoundsBase, An extendable abstraction layer","text":"AbstractRelaxProblemAttribute\r\nHasStateBounds\r\nHasConstantStateBounds\r\nHasVariableStateBounds\r\nHasUserJacobian\r\nAbstractPathConstraint\r\nConstantStateBounds\r\nVariableStateBounds\r\nPolyhedralConstraint\r\nStateNumber\r\nConstantParameterValue\r\nParameterNumber\r\nSupportNumber","category":"page"},{"location":"Base/Base.html#DynamicBoundsBase.AbstractRelaxProblemAttribute","page":"DynamicsBoundsBase, An extendable abstraction layer","title":"DynamicBoundsBase.AbstractRelaxProblemAttribute","text":"abstract type AbstractRelaxProblemAttribute\n\nAbstract supertype for all problem attributes.\n\n\n\n\n\n","category":"type"},{"location":"Base/Base.html#DynamicBoundsBase.HasStateBounds","page":"DynamicsBoundsBase, An extendable abstraction layer","title":"DynamicBoundsBase.HasStateBounds","text":"struct HasStateBounds <: AbstractRelaxProblemAttribute\n\nA problem attribute used to check whether state bounds are defined.\n\n\n\n\n\n","category":"type"},{"location":"Base/Base.html#DynamicBoundsBase.HasConstantStateBounds","page":"DynamicsBoundsBase, An extendable abstraction layer","title":"DynamicBoundsBase.HasConstantStateBounds","text":"struct HasConstantStateBounds <: AbstractRelaxProblemAttribute\n\nA problem attribute used to check whether state bounds are defined as constant.\n\n\n\n\n\n","category":"type"},{"location":"Base/Base.html#DynamicBoundsBase.HasVariableStateBounds","page":"DynamicsBoundsBase, An extendable abstraction layer","title":"DynamicBoundsBase.HasVariableStateBounds","text":"struct HasVariableStateBounds <: AbstractRelaxProblemAttribute\n\nA problem attribute used to check whether variable state bounds are defined.\n\n\n\n\n\n","category":"type"},{"location":"Base/Base.html#DynamicBoundsBase.HasUserJacobian","page":"DynamicsBoundsBase, An extendable abstraction layer","title":"DynamicBoundsBase.HasUserJacobian","text":"struct HasUserJacobian <: AbstractRelaxProblemAttribute\n\nA problem attribute used to check whether a user-defined jacobian was specified.\n\n\n\n\n\n","category":"type"},{"location":"Base/Base.html#DynamicBoundsBase.AbstractPathConstraint","page":"DynamicsBoundsBase, An extendable abstraction layer","title":"DynamicBoundsBase.AbstractPathConstraint","text":"abstract type AbstractPathConstraint <: AbstractRelaxProblemAttribute\n\nAn abstract supertype for all manners of path constraints.\n\n\n\n\n\n","category":"type"},{"location":"Base/Base.html#DynamicBoundsBase.ConstantStateBounds","page":"DynamicsBoundsBase, An extendable abstraction layer","title":"DynamicBoundsBase.ConstantStateBounds","text":"struct ConstantStateBounds <: AbstractRelaxProblemAttribute\n\nA problem attribute used to store constant state bounds.\n\nxL::Vector{Float64}\nLower state variable bounds\nxU::Vector{Float64}\nUpper state variable bounds\n\n\n\n\n\n","category":"type"},{"location":"Base/Base.html#DynamicBoundsBase.VariableStateBounds","page":"DynamicsBoundsBase, An extendable abstraction layer","title":"DynamicBoundsBase.VariableStateBounds","text":"struct VariableStateBounds{F1<:Function, F2<:Function} <: AbstractRelaxProblemAttribute\n\nA problem attribute used to store time-varying state bounds.\n\nxL::Function\nLower state variable bounds\nxU::Function\nUpper state variable bounds\n\n\n\n\n\n","category":"type"},{"location":"Base/Base.html#DynamicBoundsBase.PolyhedralConstraint","page":"DynamicsBoundsBase, An extendable abstraction layer","title":"DynamicBoundsBase.PolyhedralConstraint","text":"struct PolyhedralConstraint <: AbstractPathConstraint\n\nAn object used to specify that the invariant Ax(t,p) <= b is valid fo all t.\n\n\n\n\n\n","category":"type"},{"location":"Base/Base.html#DynamicBoundsBase.StateNumber","page":"DynamicsBoundsBase, An extendable abstraction layer","title":"DynamicBoundsBase.StateNumber","text":"struct StateNumber\n\nAn integrator attribute retrieving the number of state variables (x) aka nx.\n\n\n\n\n\n","category":"type"},{"location":"Base/Base.html#DynamicBoundsBase.ConstantParameterValue","page":"DynamicsBoundsBase, An extendable abstraction layer","title":"DynamicBoundsBase.ConstantParameterValue","text":"struct ConstantParameterValue <: AbstractIntegratorAttribute\n\nA integrator attribute used to access the constant parameter values.\n\n\n\n\n\n","category":"type"},{"location":"Base/Base.html#DynamicBoundsBase.ParameterNumber","page":"DynamicsBoundsBase, An extendable abstraction layer","title":"DynamicBoundsBase.ParameterNumber","text":"struct ParameterNumber\n\nAn integrator attribute retrieving the number of parameter variables (p) aka np.\n\n\n\n\n\n","category":"type"},{"location":"Base/Base.html#DynamicBoundsBase.SupportNumber","page":"DynamicsBoundsBase, An extendable abstraction layer","title":"DynamicBoundsBase.SupportNumber","text":"struct SupportNumber\n\nAn integrator attribute retrieving the number of points in the support set of (x) aka nt.\n\n\n\n\n\n","category":"type"},{"location":"Base/Base.html#Abstract-Integrator-Types","page":"DynamicsBoundsBase, An extendable abstraction layer","title":"Abstract Integrator Types","text":"","category":"section"},{"location":"Base/Base.html","page":"DynamicsBoundsBase, An extendable abstraction layer","title":"DynamicsBoundsBase, An extendable abstraction layer","text":"AbstractDERelaxIntegrator\r\nAbstractODERelaxIntegrator","category":"page"},{"location":"Base/Base.html#DynamicBoundsBase.AbstractDERelaxIntegrator","page":"DynamicsBoundsBase, An extendable abstraction layer","title":"DynamicBoundsBase.AbstractDERelaxIntegrator","text":"abstract type AbstractDERelaxIntegrator\n\nAbstract supertype for any integrator that constructs relaxations of a differential equation problem.\n\n\n\n\n\n","category":"type"},{"location":"Base/Base.html#DynamicBoundsBase.AbstractODERelaxIntegrator","page":"DynamicsBoundsBase, An extendable abstraction layer","title":"DynamicBoundsBase.AbstractODERelaxIntegrator","text":"abstract type AbstractODERelaxIntegrator <: AbstractDERelaxIntegrator\n\nAbstract supertype for any integrator that constructs relaxations of an ordinary differential equation problem.\n\n\n\n\n\n","category":"type"},{"location":"Base/Base.html","page":"DynamicsBoundsBase, An extendable abstraction layer","title":"DynamicsBoundsBase, An extendable abstraction layer","text":"Bound locations for use with attributes such as Relaxation, Bound, Gradient. For Gradient{T<:AbstractBoundLoc}, T = Lower indicates the gradient of the lower relaxation (that is the convex relaxation) should be returned, T = Upper indicates that the upper relaxation (the concave relaxation) should be returned, T = Nominal indicates that the gradient of the local evaluation of the relaxation should be returned at the present parameter value.","category":"page"},{"location":"Base/Base.html","page":"DynamicsBoundsBase, An extendable abstraction layer","title":"DynamicsBoundsBase, An extendable abstraction layer","text":"AbstractBoundLoc\r\nLower\r\nUpper\r\nNominal\r\nUndefined","category":"page"},{"location":"Base/Base.html#DynamicBoundsBase.AbstractBoundLoc","page":"DynamicsBoundsBase, An extendable abstraction layer","title":"DynamicBoundsBase.AbstractBoundLoc","text":"abstract type AbstractBoundLoc\n\nAbstract supertype indicating the type of value returned at a specific index.\n\n\n\n\n\n","category":"type"},{"location":"Base/Base.html#DynamicBoundsBase.Lower","page":"DynamicsBoundsBase, An extendable abstraction layer","title":"DynamicBoundsBase.Lower","text":"struct Lower <: AbstractBoundLoc\n\nIndicates the lower bound, relaxation, or (sub)gradient should be returned.\n\n\n\n\n\n","category":"type"},{"location":"Base/Base.html#DynamicBoundsBase.Upper","page":"DynamicsBoundsBase, An extendable abstraction layer","title":"DynamicBoundsBase.Upper","text":"struct Upper <: AbstractBoundLoc\n\nIndicates the upper bound, relaxation, or (sub)gradient should be returned.\n\n\n\n\n\n","category":"type"},{"location":"Base/Base.html#DynamicBoundsBase.Nominal","page":"DynamicsBoundsBase, An extendable abstraction layer","title":"DynamicBoundsBase.Nominal","text":"struct Nominal <: AbstractBoundLoc\n\nIndicates the nominal value or (sub)gradient should be returned.\n\n\n\n\n\n","category":"type"},{"location":"Base/Base.html#DynamicBoundsBase.Undefined","page":"DynamicsBoundsBase, An extendable abstraction layer","title":"DynamicBoundsBase.Undefined","text":"struct Undefined <: AbstractBoundLoc\n\nThe variety of the attribute is unspecified.\n\n\n\n\n\n","category":"type"},{"location":"Base/Base.html#Integrator-attributes","page":"DynamicsBoundsBase, An extendable abstraction layer","title":"Integrator attributes","text":"","category":"section"},{"location":"Base/Base.html","page":"DynamicsBoundsBase, An extendable abstraction layer","title":"DynamicsBoundsBase, An extendable abstraction layer","text":"AbstractIntegratorAttribute\r\nAbstractDynamicIndex\r\nTimeIndex\r\nIntegratorName\r\nIsNumeric\r\nIsSolutionSet\r\nTerminationStatus\r\nValue\r\nSupportSet{T<:AbstractFloat}\r\nParameterValue\r\nParameterBound{T<:AbstractBoundLoc}\r\nBound{T<:AbstractBoundLoc}\r\nRelaxation{T<:AbstractBoundLoc}\r\nGradient{T<:AbstractBoundLoc}\r\nSubgradient{T<:AbstractBoundLoc}\r\nLocalIntegrator\r\nAttachedProblem\r\nLocalSensitivityOn","category":"page"},{"location":"Base/Base.html#DynamicBoundsBase.AbstractIntegratorAttribute","page":"DynamicsBoundsBase, An extendable abstraction layer","title":"DynamicBoundsBase.AbstractIntegratorAttribute","text":"abstract type AbstractIntegratorAttribute\n\nAbstract supertype for attributes that can be used to set or get attributes (properties) of variables in the model.\n\n\n\n\n\n","category":"type"},{"location":"Base/Base.html#DynamicBoundsBase.AbstractDynamicIndex","page":"DynamicsBoundsBase, An extendable abstraction layer","title":"DynamicBoundsBase.AbstractDynamicIndex","text":"abstract type AbstractDynamicIndex\n\nAn abstract supertype for index structures needed to reference parameters or time.\n\n\n\n\n\n","category":"type"},{"location":"Base/Base.html#DynamicBoundsBase.TimeIndex","page":"DynamicsBoundsBase, An extendable abstraction layer","title":"DynamicBoundsBase.TimeIndex","text":"struct TimeIndex\n\nA time index t used to access the value at t.i-th time point.\n\n\n\n\n\n","category":"type"},{"location":"Base/Base.html#DynamicBoundsBase.IntegratorName","page":"DynamicsBoundsBase, An extendable abstraction layer","title":"DynamicBoundsBase.IntegratorName","text":"struct IntegratorName <: AbstractIntegratorAttribute\n\nAn integrator attribute for the string identifying the integration scheme.\n\n\n\n\n\n","category":"type"},{"location":"Base/Base.html#DynamicBoundsBase.IsNumeric","page":"DynamicsBoundsBase, An extendable abstraction layer","title":"DynamicBoundsBase.IsNumeric","text":"struct IsNumeric <: AbstractIntegratorAttribute\n\nAn integrator attribute for indicating bounds/relaxations are of numeric solution.\n\n\n\n\n\n","category":"type"},{"location":"Base/Base.html#DynamicBoundsBase.IsSolutionSet","page":"DynamicsBoundsBase, An extendable abstraction layer","title":"DynamicBoundsBase.IsSolutionSet","text":"struct IsSolutionSet <: AbstractIntegratorAttribute\n\nAn integrator attribute for indicating bounds & relaxations are of exact solution.\n\n\n\n\n\n","category":"type"},{"location":"Base/Base.html#DynamicBoundsBase.TerminationStatus","page":"DynamicsBoundsBase, An extendable abstraction layer","title":"DynamicBoundsBase.TerminationStatus","text":"struct TerminationStatus <: AbstractIntegratorAttribute\n\nA integrator attribute used to query the TerminationStatusCode of the integrator on completion. Current termination status codes are:\n\nCOMPLETED: The algorithm terminate successfully with bounds and relaxations.\nEMPTY: The algorithm terminated successfully but the solution set was empty for        some points in tspan.\nNAN: The algorithm terminated but some values are not a number (usually indicating        a domain violation was encoutered when computing relaxations).\nRELAXATION_NOT_CALLED: The relaxation has not yet been computed.\nNUMERICAL_ERROR: A numerical error was encountered.\nLIMIT_EXCEEDED: A preset limit was exceeded (number of steps and so on).\nINVALID_OPTION: An invalid option was set.\nOTHER_ERROR: Another error was encountered.\n\n\n\n\n\n","category":"type"},{"location":"Base/Base.html#DynamicBoundsBase.Value","page":"DynamicsBoundsBase, An extendable abstraction layer","title":"DynamicBoundsBase.Value","text":"struct Value <: AbstractIntegratorAttribute\n\nAn integrator attribute for value of local solution bounds.\n\n\n\n\n\n","category":"type"},{"location":"Base/Base.html#DynamicBoundsBase.SupportSet","page":"DynamicsBoundsBase, An extendable abstraction layer","title":"DynamicBoundsBase.SupportSet","text":"struct SupportSet{T<:AbstractFloat} <: AbstractIntegratorAttribute\n\nA integrator attribute used to access independent variable support set.\n\n\n\n\n\n","category":"type"},{"location":"Base/Base.html#DynamicBoundsBase.ParameterValue","page":"DynamicsBoundsBase, An extendable abstraction layer","title":"DynamicBoundsBase.ParameterValue","text":"struct ParameterValue <: AbstractIntegratorAttribute\n\nA integrator attribute used to access the current parameter value.\n\n\n\n\n\n","category":"type"},{"location":"Base/Base.html#DynamicBoundsBase.ParameterBound","page":"DynamicsBoundsBase, An extendable abstraction layer","title":"DynamicBoundsBase.ParameterBound","text":"struct ParameterBound{T<:AbstractBoundLoc} <: AbstractIntegratorAttribute\n\nA integrator attribute used to access the current parameter value.\n\n\n\n\n\n","category":"type"},{"location":"Base/Base.html#DynamicBoundsBase.Bound","page":"DynamicsBoundsBase, An extendable abstraction layer","title":"DynamicBoundsBase.Bound","text":"struct Bound{T<:AbstractBoundLoc} <: AbstractIntegratorAttribute\n\nAn integrator attribute for state bounds.\n\n\n\n\n\n","category":"type"},{"location":"Base/Base.html#DynamicBoundsBase.Relaxation","page":"DynamicsBoundsBase, An extendable abstraction layer","title":"DynamicBoundsBase.Relaxation","text":"struct Relaxation{T<:AbstractBoundLoc} <: AbstractIntegratorAttribute\n\nAn integrator attribute for relaxations.\n\n\n\n\n\n","category":"type"},{"location":"Base/Base.html#DynamicBoundsBase.Gradient","page":"DynamicsBoundsBase, An extendable abstraction layer","title":"DynamicBoundsBase.Gradient","text":"struct Gradient{T<:AbstractBoundLoc} <: AbstractIntegratorAttribute\n\nAn integrator attribute for the Gradient.\n\n\n\n\n\n","category":"type"},{"location":"Base/Base.html#DynamicBoundsBase.Subgradient","page":"DynamicsBoundsBase, An extendable abstraction layer","title":"DynamicBoundsBase.Subgradient","text":"struct Subgradient{T<:AbstractBoundLoc} <: AbstractIntegratorAttribute\n\nAn integrator attribute for the Subgradient.\n\n\n\n\n\n","category":"type"},{"location":"Base/Base.html#DynamicBoundsBase.LocalIntegrator","page":"DynamicsBoundsBase, An extendable abstraction layer","title":"DynamicBoundsBase.LocalIntegrator","text":"struct LocalIntegrator <: AbstractIntegratorAttribute\n\nRetreives the LocalIntegrator that corresponds to the integration method used by the integrator.\n\n\n\n\n\n","category":"type"},{"location":"Base/Base.html#DynamicBoundsBase.AttachedProblem","page":"DynamicsBoundsBase, An extendable abstraction layer","title":"DynamicBoundsBase.AttachedProblem","text":"struct AttachedProblem <: AbstractIntegratorAttribute\n\nRetreives the problem used by the integrator.\n\n\n\n\n\n","category":"type"},{"location":"Base/Base.html#DynamicBoundsBase.LocalSensitivityOn","page":"DynamicsBoundsBase, An extendable abstraction layer","title":"DynamicBoundsBase.LocalSensitivityOn","text":"struct LocalSensitivityOn <: AbstractIntegratorAttribute\n\nSet to true if integrator should compute derivatives wrt p for the local ode integration.\n\n\n\n\n\n","category":"type"},{"location":"Base/Base.html","page":"DynamicsBoundsBase, An extendable abstraction layer","title":"DynamicsBoundsBase, An extendable abstraction layer","text":"The following constructors for integrator attributes are given below with T<:AbstractBoundLoc. The TimeIndex constructor is used to specify that the time point referenced using an integer (i.e. the first, second, or fifth time in the support set). The subgradient of the concave relaxation at the third point in the support set is then referenced using the command Subgradient{Upper}(TimeIndex(3)) whereas the subgradient of the concave relaxation at time 0.35 is referenced using Subgradient{Upper}(0.35). A full list of the AbstractIntegratorAttribute structures using this constructor are list below:","category":"page"},{"location":"Base/Base.html","page":"DynamicsBoundsBase, An extendable abstraction layer","title":"DynamicsBoundsBase, An extendable abstraction layer","text":"Gradient{T}(i::TimeIndex)\r\nGradient{T}(x::Float64)\r\nSubgradient{T}(i::TimeIndex)\r\nSubgradient{T}(x::Float64)\r\nBound{T}(i::TimeIndex)\r\nBound{T}(x::Float64)\r\nRelaxation{T}(i::TimeIndex)\r\nRelaxation{T}(x::Float64)","category":"page"},{"location":"Base/Base.html#Access-and-Interface-Functions:","page":"DynamicsBoundsBase, An extendable abstraction layer","title":"Access and Interface Functions:","text":"","category":"section"},{"location":"Base/Base.html","page":"DynamicsBoundsBase, An extendable abstraction layer","title":"DynamicsBoundsBase, An extendable abstraction layer","text":"supports\r\nget\r\ngetall\r\ngetall!\r\nset!\r\nsetall!\r\nrelax!\r\nintegrate!","category":"page"},{"location":"Base/Base.html#DynamicBoundsBase.supports","page":"DynamicsBoundsBase, An extendable abstraction layer","title":"DynamicBoundsBase.supports","text":"supports\n\nReturn a Bool indicating whether ::AbstractDERelaxIntegrator supports the ::Union{AbstractDERelaxIntegrator, AbstractDERelaxProblem}.\n\n\n\n\n\n","category":"function"},{"location":"Base/Base.html#Base.get","page":"DynamicsBoundsBase, An extendable abstraction layer","title":"Base.get","text":"get\n\nReturns the value of attribute set for the ::Union{AbstractDERelaxIntegrator, AbstractDERelaxProblem}. May be vector valued.\n\n\n\n\n\n","category":"function"},{"location":"Base/Base.html#DynamicBoundsBase.getall","page":"DynamicsBoundsBase, An extendable abstraction layer","title":"DynamicBoundsBase.getall","text":"getall\n\nAn version of get which retreives all data asssociated with a particular integrator attribute.\n\n\n\n\n\n","category":"function"},{"location":"Base/Base.html#DynamicBoundsBase.getall!","page":"DynamicsBoundsBase, An extendable abstraction layer","title":"DynamicBoundsBase.getall!","text":"getall!\n\nAn in-place version of get! which retreives all data asssociated with a particular integrator attribute.\n\n\n\n\n\n","category":"function"},{"location":"Base/Base.html#DynamicBoundsBase.set!","page":"DynamicsBoundsBase, An extendable abstraction layer","title":"DynamicBoundsBase.set!","text":"set!\n\nAssigns a value to the attr attribute of the integrator, problem, or relaxation.\n\n\n\n\n\n","category":"function"},{"location":"Base/Base.html#DynamicBoundsBase.setall!","page":"DynamicsBoundsBase, An extendable abstraction layer","title":"DynamicBoundsBase.setall!","text":"setall!\n\nAn in-place version of set! which sets all data asssociated with a particular integrator attribute.\n\n\n\n\n\n","category":"function"},{"location":"Base/Base.html#DynamicBoundsBase.relax!","page":"DynamicsBoundsBase, An extendable abstraction layer","title":"DynamicBoundsBase.relax!","text":"relax!\n\nComputes the relaxation at the current parameter value with the current parameter and state bounds.\n\n\n\n\n\n","category":"function"},{"location":"Base/Base.html#DynamicBoundsBase.integrate!","page":"DynamicsBoundsBase, An extendable abstraction layer","title":"DynamicBoundsBase.integrate!","text":"integrate!\n\nProvides a real-value integration at the current value set for each parameter.\n\n\n\n\n\n","category":"function"},{"location":"Base/Base.html#General-utilities:","page":"DynamicsBoundsBase, An extendable abstraction layer","title":"General utilities:","text":"","category":"section"},{"location":"Base/Base.html","page":"DynamicsBoundsBase, An extendable abstraction layer","title":"DynamicsBoundsBase, An extendable abstraction layer","text":"IntegratorStates\r\nUnsupportedError\r\nNotAllowedError\r\nUnsupportedRelaxAttribute{AttrType<:AnyDEAttribute}\r\nSetRelaxAttributeNotAllowed{AttrType<:AnyDEAttribute}","category":"page"},{"location":"Base/Base.html#DynamicBoundsBase.IntegratorStates","page":"DynamicsBoundsBase, An extendable abstraction layer","title":"DynamicBoundsBase.IntegratorStates","text":"mutable struct IntegratorStates\n\nA structure that holds the state of the integrator.\n\nfirst_pnt_eval::Bool\nHas the first point been evaluated\nnew_decision_box::Bool\nHave the box-constraints changed since the last evaluation\nnew_decision_pnt::Bool\nHas the decision point changed since the last evaluation\nset_lower_state::Bool\nThe relaxed problem has been updated\nset_upper_state::Bool\nThe local problem has been updated\ntermination_status::TerminationStatusCode\nHow did the integrator terminate\n\n\n\n\n\n","category":"type"},{"location":"Base/Base.html#DynamicBoundsBase.UnsupportedError","page":"DynamicsBoundsBase, An extendable abstraction layer","title":"DynamicBoundsBase.UnsupportedError","text":"UnsupportedError <: Exception\n\nAbstract type for error thrown when an element is not supported by the integrator.\n\n\n\n\n\n","category":"type"},{"location":"Base/Base.html#DynamicBoundsBase.NotAllowedError","page":"DynamicsBoundsBase, An extendable abstraction layer","title":"DynamicBoundsBase.NotAllowedError","text":"NotAllowedError <: Exception\n\nAbstract type for error thrown when an operation is supported but cannot be applied in the current state of the integrator .\n\n\n\n\n\n","category":"type"},{"location":"Base/Base.html#DynamicBoundsBase.UnsupportedRelaxAttribute","page":"DynamicsBoundsBase, An extendable abstraction layer","title":"DynamicBoundsBase.UnsupportedRelaxAttribute","text":"struct UnsupportedRelaxAttribute{AttrType<:Union{AbstractIntegratorAttribute, AbstractRelaxProblemAttribute}} <: UnsupportedError\n\nAn error indicating that the attribute attr is unsupported.\n\n\n\n\n\n","category":"type"},{"location":"Base/Base.html#DynamicBoundsBase.SetRelaxAttributeNotAllowed","page":"DynamicsBoundsBase, An extendable abstraction layer","title":"DynamicBoundsBase.SetRelaxAttributeNotAllowed","text":"struct SetRelaxAttributeNotAllowed{AttrType<:Union{AbstractIntegratorAttribute, AbstractRelaxProblemAttribute}} <: NotAllowedError\n\nAn error indicating that the attribute attr is supported but cannot be set for some reason given in the error string.\n\n\n\n\n\n","category":"type"}]
}
